
# 📌 정렬 알고리즘

<br/>

## 목차
1. [정렬 알고리즘 (sorting algorithm)](#-정렬-알고리즘-sorting-algorithm)
2. [버블 정렬 (bubble sort)](#-버블-정렬-bubble-sort)
3. [선택 정렬 (selection sort)](#-선택-정렬-selection-sort)
4. [삽입 정렬 (insertion sort)](#-삽입-정렬-insertion-sort)
5. [합병 정렬 (merge sort)](#-합병-정렬-merge-sort)
6. [퀵 정렬 (quick sort)](#-퀵-정렬-quick-sort)
7. [힙 정렬 (heap sort)](#-힙-정렬-heap-sort)
8. [기수 정렬 (radix sort)](#-기수-정렬-radix-sort)
9. [계수 정렬 (counting sort)](#-계수-정렬-counting-sort)

<br/><br/>

## ✅ 정렬 알고리즘 (sorting algorithm)
: 번호순이나 사전 순서와 같이 일정한 순서대로 열거하는 알고리즘

<br/>

![](https://gmlwjd9405.github.io/images/algorithm-heap-sort/sort-time-complexity.png) <br/>
출처: [정렬 알고리즘 시간복잡도](https://gmlwjd9405.github.io/2018/05/10/algorithm-heap-sort.html)


<br/><br/>
<br/>

## ✅ 버블 정렬 (bubble sort)
: **양 옆에 위치한 두 값을 비교하면서 크기 순으로 정렬하는 방식**
- **비교 기반** 정렬 알고리즘 
- 인접한 두 요소를 비교해 필요한 경우 위치를 바꾸고, 이 과정을 반복하면서 큰 값이 배열의 끝으로 '거품처럼' 떠오르도록 한다. 
- **단점**
  - **성능이 좋지 않아 잘 사용되지 않는다.**
  - 작은 데이터셋에서만 유용하다. 
- **시간 복잡도**
  - **최악의 경우 시간 복잡도**
    - `O(n²)`
     - n개의 요소가 있을 때, 한 번의 패스에서 n-1번 비교하고, 그다음 패스에서는 n-2번 비교하므로 전체 연산 횟수는 `(n-1) + (n-2) + ... + 1 = O(n²)`이다.
  - **공간 복잡도**
    - `O(1)`
     - 배열 내에서 값을 교환하기 때문에 추가적인 메모리 공간이 필요없다.

<br/>

### ☑️ 버블 정렬의 동작 방식
1. **배열의 첫 번째 요소부터 시작하여 인접한 두 값을 차례대로 비교한다.**
2. **현재 요소(a)와 그 다음 요소(b)를 비교해, b가 a보다 작다면 두 값을 교환한다.**
3. **배열의 끝까지 이 과정을 반복하고, 마지막 요소는 가장 큰 값이 된다.**
4. **마지막 값을 제외한 나머지 배열에 대해 같은 과정을 반복한다.**
5. **배열이 완전히 정렬될 때까지 반복한다.**

<br/>

- **예시**
![](https://velog.velcdn.com/images/049494/post/af4efce0-6c87-4077-8ee9-fade1fcde9af/image.png) <br/>
출처: [버블정렬](https://velog.io/@049494/%EB%B2%84%EB%B8%94-%EC%A0%95%EB%A0%AC)

<br/>

- 첫 번째 패스
  - 비교 1: 5와 3을 비교 → `5 > 3`이므로 교환 <br/> ➡︎ `[3, 5, 8, 1, 2, 7]`
  - 비교 2: 5와 8을 비교 → `5 < 8`이므로 교환 없음 <br/> ➡︎ `[3, 5, 8, 1, 2, 7]`
  - 비교 3: 8과 1을 비교 → `8 > 1`이므로 교환 <br/> ➡︎ `[3, 5, 1, 8, 2, 7]`
  - 비교 4: 8과 2를 비교 → `8 > 2`이므로 교환 <br/> ➡︎ `[3, 5, 1, 2, 8, 7]`
  - 비교 5: 8과 7을 비교 → `8 > 7`이므로 교환 <br/> ➡︎ `[3, 5, 1, 2, 7, 8]`

- 두 번째 패스
  - 비교 1: 3과 5를 비교 → `3 < 5`이므로 교환 없음 <br/> ➡︎ `[3, 5, 1, 2, 7, 8]`
  - 비교 2: 5와 1을 비교 → `5 > 1`이므로 교환 <br/> ➡︎ `[3, 1, 5, 2, 7, 8]`
  - 비교 3: 5와 2를 비교 → `5 > 2`이므로 교환 <br/> ➡︎ `[3, 1, 2, 5, 7, 8]`
  - 비교 4: 5와 7을 비교 → `5 < 7`이므로 교환 없음 <br/> ➡︎ [3, 1, 2, 5, 7, 8]`

- 세 번째 패스
  - 비교 1: 3과 1을 비교 → `3 > 1`이므로 교환 <br/> ➡︎ `[1, 3, 2, 5, 7, 8]`
  - 비교 2: 3과 2를 비교 → `3 > 2`이므로 교환 <br/> ➡︎ `[1, 2, 3, 5, 7, 8]`
  - 비교 3: 3과 5를 비교 → `3 < 5`이므로 교환 없음 <br/> ➡︎ `[1, 2, 3, 5, 7, 8]`

- 네 번째 패스
  - 비교 1
     - 1과 2를 비교 → `1 < 2`이므로 교환 없음 <br/> ➡︎ `[1, 2, 3, 5, 7, 8]`

- 최종 정렬된 배열 ➡︎ `[1, 2, 3, 5, 7, 8]`

<br/><br/>
<br/>
  
## ✅ 선택 정렬 (selection sort)
: **배열을 순회하면서 각 위치에 들어갈 적절한 값을 선택하여 자리를 바꿔 정렬하는 방식**
- **비교 기반**의 정렬 알고리즘
- **단점**
  - 단순한 구현이 가능하지만, 성능이 느리기 때문에 일반적으로 큰 데이터셋에서는 사용되지 않는다.
- **시간 복잡도**
  - **최악의 경우 시간 복잡도**
    - `O(n²)`
    - 각 패스마다 최솟값을 찾기 위해 n번, n-1번, n-2번 등의 비교를 수행하므로 전체 연산 횟수는 `(n-1) + (n-2) + ... + 1 = O(n²)`이다.
  - **공간 복잡도**
    - `O(1)`
    - 선택 정렬은 배열 내에서 값을 교환하기 때문에 추가적인 메모리 공간이 필요하지 않다.

<br/>

### ☑️ 선택 정렬의 동작 방식
1. 배열의 첫 번째 요소부터 마지막 요소까지 차례대로 **각 자리에 들어갈 최솟값을 선택**한다.
2. 첫 번째 패스에서는 **배열 전체에서 가장 작은 값을 찾아 첫 번째 위치에 놓는다.**
3. 두 번째 패스에서는 **두 번째 자리부터 끝까지 비교하여 다음으로 작은 값을 찾아 두 번째 위치에 놓는다.**
4. 이러한 방식으로 배열의 모든 요소를 정렬한다.

<br/>

- **예시**
![](https://velog.velcdn.com/images/049494/post/422817d1-a52b-4f26-98c4-75bfcd5ed6f9/image.png) <br/>
출처: [선택정렬](https://velog.io/@049494/%EC%84%A0%ED%83%9D-%EC%A0%95%EB%A0%AC)

<br/>

- 배열 `[5, 3, 8, 1, 2, 7]`
  1. 배열에서 **가장 작은 값 1**을 찾아 첫 번째 자리에 위치 <br/>
  ➡︎ `[1, 3, 8, 5, 2, 7]`
  
  2. 남은 배열에서 **가장 작은 값 2**를 찾아 두 번째 자리에 위치 <br/>
  ➡︎ `[1, 2, 8, 5, 3, 7]`
  3. 남은 배열에서 **가장 작은 값 3**을 찾아 세 번째 자리에 위치 <br/>
  ➡︎ `[1, 2, 3, 5, 8, 7]`
  4. 남은 배열에서 **가장 작은 값 5**를 찾아 네 번째 자리에 위치 <br/>
  ➡︎ `[1, 2, 3, 5, 8, 7]` (이미 정렬됨)
  5. 마지막으로 **가장 작은 값 7**을 찾아 다섯 번째 자리에 위치 <br/>
  ➡︎ `[1, 2, 3, 5, 7, 8]`
  - 최종 배열 ➡︎ `[1, 2, 3, 5, 7, 8]`

<br/><br/>
<br/>

## ✅ 삽입 정렬 (insertion sort)
: **배열을 앞에서부터 순회하면서 정렬된 부분의 적절한 위치에 값을 삽입하는 방식**
- **시간 복잡도**
   - `O(n²)`
      - 삽입 정렬은 전체 배열을 순회하며 각 순회에서 인덱스 i 요소를 적절한 위치에 삽입하기 위해 최대 n-i번을 탐색한다. 
      - 따라서 `1 + 2 + ... + (n-2) + (n-1) = `번 연산을 수행하며, <br/> 시간 복잡도는 O(n2)이 된다.
    - 배열이 거의 정렬되어 있을 때는 효율적이다.

<br/>

### ☑️ 삽입 정렬의 동작 방식
1. **처음 한 요소를 정렬된 상태로 간주**
   - 리스트의 첫 번째 요소는 이미 정렬된 상태로 생각한다.
2. **다음 요소를 정렬된 부분에 삽입**
   - 정렬되지 않은 부분에서 첫 번째 요소를 선택하여, 정렬된 부분의 적절한 위치에 삽입한다.
   - 정렬된 부분의 요소들은 오른쪽으로 밀려난다.
3. **이 과정을 반복**
   - 모든 요소가 정렬될 때까지 이 과정을 반복한다.

<br/>

- **예시**
![](https://t1.daumcdn.net/cfile/tistory/2569FD3854508BE811) <br/>
출처: [삽입정렬](https://wonjayk.tistory.com/218)

<br/>

1. 첫 번째 요소 5는 이미 정렬된 상태로 간주 <br/>
  ➡︎ `[5, 3, 8, 1, 2, 7]`
2. 3을 적절한 위치인 5 앞에 삽입 <br/>
  ➡︎ `[3, 5, 8, 1, 2, 7]`
3. 8은 제자리에 유지 <br/>
  ➡︎ `[3, 5, 8, 1, 2, 7]`
4. 1을 적절한 위치인 3 앞에 삽입 <br/>
  ➡︎ `[1, 3, 5, 8, 2, 7]`
5. 2를 1과 3 사이에 삽입 <br/>
  ➡︎ `[1, 2, 3, 5, 8, 7]`
6. 마지막으로 7을 8 앞에 삽입 <br/>
  ➡︎ `[1, 2, 3, 5, 7, 8]`
- 최종 배열 ➡︎ [1, 2, 3, 5, 7, 8]`

<br/><br/>
<br/>

## ✅ 합병 정렬 (merge sort)
: **정렬하려는 배열을 크기가 0 또는 1이 될 때까지 절반씩 분할**하고, <br/>
 **분할된 각각의 배열을 다시 하나의 배열로 합쳐서 정렬하는 방식**
- **재귀를 이용하는 분할 정복 알고리즘**
  - **분할**: 배열을 쪼개는 것
  - **정복**: 분할한 배열을 정렬하면서 하나로 합병하는 것

<br/>

### ☑️ 합병 정렬의 작동 방식
1. **분할**
   - **입력 배열을 같은 크기의 2개의 부분 배열로 나눈다.**
2. **정렬**
   - **부분 배열을 정렬한다.**
   - 부분 배열의 크기가 충분히 작지 않으면, 순환 호출을 통해 다시 분할 정복 방법을 적용한다.
3. **합병**
   - **정렬된 부분 배열들을 하나의 배열로 합친다.**
   - 합칠 때는 두 리스트의 앞에서부터 요소를 비교하여 작은 것부터 새로운 배열에 넣는다.

<br/>

- **예시**
![](https://blog.kakaocdn.net/dn/TMJkj/btqFOh3IneD/6DL0SGqullOF1CUkJsnB6k/img.png)
출처: [합병정렬](https://nox1004.tistory.com/entry/%ED%95%A9%EB%B3%91%EC%A0%95%EB%A0%AC)

<br/>

1. 분할
   - 배열을 반으로 나눈다.
     - `[27, 10, 12, 20, 25, 13, 15, 22]`을 `[27, 10, 12, 20]`과 `[25, 13, 15, 22]`로 나눈다.
     - `[27, 10, 12, 20]`을 [27, 10]과 [12, 20]로 나눈다.
     - `[25, 13, 15, 22]`을 [25, 13]과 [15, 22]로 나눈다.
   - 이어서 각각의 배열을 더 나눈다.
     - `[27, 10]`을 [27]과 [10]으로 나눈다.
     - `[12, 20]`을 [12]와 [20]으로 나눈다.
     - `[25, 13]`을 [25]와 [13]으로 나눈다.
     - `[15, 22]`을 [15]와 [22]로 나눈다.

2. 정렬
   - 각 배열을 정렬한 후 합친다.
   - [27]과 [10]을 합쳐 [10, 27]로 정렬한다.
   - [12]와 [20]을 합쳐 [12, 20]으로 정렬한다.
   - [25]와 [13]을 합쳐 [13, 25]로 정렬한다.
   - [15]과 [22]을 합쳐 [15, 22]로 정렬한다.
3. 합병
   - `[10, 27]`과 `[12, 20]`을 합친다.
     - 비교: 10과 12 → 10을 새로운 리스트에 추가
     - 비교: 27과 12 → 12을 추가
     - 비교: 27과 20 → 20을 추가
     - 나머지 27을 추가
     - 결과 ➡︎ `[10, 12, 20, 27]`
   - `[13, 25]`과 `[15, 22]`을 합친다.
     - 비교: 13과 15 → 13을 새로운 리스트에 추가
     - 비교: 25와 15 → 15을 추가
     - 비교: 25와 22 → 22을 추가
     - 나머지 25을 추가
     - 결과 ➡︎ `[13, 15, 22, 25]`
   - `[10, 12, 20, 27]`과 `[13, 15, 22, 25]`을 최종적으로 합친다.
     - 비교: 10과 13 → 10을 새로운 리스트에 추가
     - 비교: 12과 13 → 12을 추가
     - 비교: 20과 13 → 13을 추가
     - 비교: 20과 15 → 15을 추가
     - 비교: 20과 22 → 20을 추가
     - 비교: 27과 22 → 22을 추가
     - 나머지 25과 27을 추가
- 최종 결과 ➡︎ `[10, 12, 13, 15, 20, 22, 25, 27]`

<br/><br/>
<br/>

## ✅ 퀵 정렬 (quick sort)
: 배열을 **피봇이라는 기준으로 나누면서 정렬하는 방식**
- **분할 정복 알고리즘**
- **시간 복잡도**
   - `O(n log n)`

<br/>

### ☑️ 퀵 정렬의 작동 방식
- ****피봇 선택**
  - 배열에서 **하나의 값을 피봇으로 선택**한다. 
  - 보통 **배열의 첫 번째나 마지막 요소**를 선택한다.
- **분할**
  - **피봇보다 작은 값들은 왼쪽으로, 피봇보다 큰 값들은 오른쪽으로 나눈다.**
  - 배열을 두 부분으로 나누는 작업을 계속 반복한다.
- **정렬**
  - 피봇을 기준으로 **나뉜 두 부분에서 다시 각각 피봇을 선택해 위 과정을 반복**한다.
  - **배열이 더 이상 나눌 수 없을 때까지 분할 작업을 계속한다.**
- **병합**
  - **모든 부분 배열이 정렬되면, 합쳐서 최종 정렬된 배열을 만든다.**

<br/>

- **예시**

![](https://gmlwjd9405.github.io/images/algorithm-quick-sort/quick-sort.png) <br/>
출처: [퀵 정렬](https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html)

<br/>

1. 피봇 선택
   - 처음으로 배열의 첫 번째 요소인 `5`를 피봇으로 선택한다.

2. 분할
   - `5`보다 작은 값은 왼쪽, 큰 값은 오른쪽으로 옮긴다.
   - 결과: `[2, 4, 1, 2] + [5] + [8, 9, 6, 7]`
     - 5보다 작은 값: `[2, 4, 1, 2]`
     - 피봇: `[5]`
     - 5보다 큰 값: `[8, 9, 6, 7]`

3. 왼쪽 부분 정렬 `[2, 4, 1, 2]`
   - 이 부분에서 다시 첫 번째 요소인 `2`를 피봇으로 선택한다.
   - `2`보다 작은 값은 없고, `2`보다 큰 값은 오른쪽으로 간다.
   - 결과: `[1, 2] + [2] + [4]`
     - 2보다 작은 값: `[1]`
     - 피봇: `[2]`
     - 2보다 큰 값: `[4]`
   - 이제 `[1, 2]`는 정렬 완료.

4. 오른쪽 부분 정렬 `[8, 9, 6, 7]`
   - 오른쪽 부분에서 첫 번째 요소 `8`을 피봇으로 선택한다.
   - `8`보다 작은 값은 왼쪽, 큰 값은 오른쪽으로 나눈다.
   - 결과: `[6, 7] + [8] + [9]`
     - 8보다 작은 값: `[6, 7]`
     - 피봇: `[8]`
     - 8보다 큰 값: `[9]`
   - `[6, 7]` 부분에서는 다시 `6`을 피봇으로 선택해 정렬하면 `[6, 7]`은 이미 정렬된 상태이다.

5. 최종 정렬
   - 왼쪽: `[1, 2, 2, 4]`
   - 피봇: `[5]`
   - 오른쪽: `[6, 7, 8, 9]`
   - 모든 부분을 합친 최종 정렬된 배열 ➡︎ `[1, 2, 2, 4, 5, 6, 7, 8, 9]`

<br/><br/>
<br/>

## ✅ 힙 정렬 (heap sort)
: **최대 힙이나 최소 힙 자료구조를 이용**해 정렬하는 방식
- **비교 기반 정렬 알고리즘**
- **힙(heap)**
  - 완전 이진 트리의 일종으로 우선순위 큐를 위하여 만들어진 자료구조
  - 최댓값, 최솟값을 쉽게 추출할 수 있는 자료구조
- **시간 복잡도**
   - 힙 생성: `O(log n)`
   - 전체 정렬 시간: `O(n log n)`
      - 배열의 모든 요소에 대해 이 과정을 반복하기 때문이다.

<br/>

### ☑️ 힙 정렬의 작동 방식
- **최대 힙 또는 최소 힙을 이용해 배열을 정렬**한다. 
- 과정은 크게 **힙 생성**과 **정렬**로 나뉜다.

1. **힙 생성(Heapify)**
   1. 배열을 힙 구조로 변환한다. 
      - 최대 힙을 사용할 경우, 부모 노드는 항상 자식 노드보다 크다.
   2. 힙을 만들기 위해, 배열을 마지막 부모 노드부터 시작해 아래로 내려가면서 자식들과 비교하고, 더 큰 값을 부모로 올려서 힙 성질을 유지한다.
   3. 이 과정을 배열의 처음까지 반복한다.
2. **정렬**
   1. 힙이 완성되면, 가장 큰 값(최대 힙의 루트)을 배열의 끝으로 보낸다.
   2. 루트 값과 배열의 끝 값을 교환한 후, 배열의 나머지 부분을 다시 힙으로 만든다. 
      - 그러면 두 번째로 큰 값이 배열 끝에서 두 번째 자리에 오게 된다.
   3. 이 과정을 배열의 크기가 1이 될 때까지 반복한다.

<br/>

- **예시**

![](https://velog.velcdn.com/images%2Fkihyun%2Fpost%2F73d9c320-9c95-4dfd-a11b-a386c9b166cf%2Fimage.png) <br/>
출처: [힙 정렬](https://velog.io/@kihyun/1.-%ED%9E%99-%EC%A0%95%EB%A0%AC-1)

<br/>

1. 최대 힙 만들기
   - 배열 `[12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]`을 최대 힙으로 변환한다. 
   - 이 배열은 이미 최대 힙의 형태를 갖추고 있으므로 추가 작업이 필요없다.

2. 정렬 과정
   - 1차 교환
     - 루트 노드 `12`와 마지막 요소 1을 교환하여 배열의 끝에 12를 위치시킨다. 
     - 배열은 `[1, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 12]`가 된다.
     - 남은 부분 `[1, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]`을 다시 최대 힙으로 만든다. 
     - 이 과정에서 루트 노드가 11로 바뀐다.

   - 2차 교환
     - 루트 노드 11과 배열의 끝 요소 2를 교환하여 배열의 끝에 11을 위치시킨다. 
     - 배열은 `[2, 9, 10, 5, 8, 7, 6, 1, 4, 3, 12, 11]`가 된다.
     - 남은 부분 `[2, 9, 10, 5, 8, 7, 6, 1, 4, 3]`을 다시 최대 힙으로 만든다. 
     - 이 과정에서 루트 노드가 10으로 바뀐다.

   - 최종 정렬
      - 이 과정을 반복하여 배열의 모든 요소를 정렬하면, 최종적으로 `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]`가 된다.


<br/><br/>
<br/>

## ✅ 기수 정렬 (radix sort)
: 1,10,100... 등 **각 자리수를 기준으로 비교없이 정렬하는 정렬 알고리즘**
- **비교하지 않는** 정렬 알고리즘
- **단점**
   - 추가 메모리가 필요하다.
   - 정렬할 수 있는 데이터 타입이 숫자로 제한된다.

<br/>

### ☑️ 기수 정렬의 작동 방식
1. **자릿수 기준으로 정렬**
   - 숫자를 낮은 자릿수부터 높은 자릿수까지 정렬한다.
     - ex) 123과 456을 정렬할 때, 먼저 1의 자릿수부터 시작하고, <br/> 
그 다음 10의 자릿수, 마지막으로 100의 자릿수로 정렬한다.

2. **버킷 사용**
   - 각 자릿수의 숫자에 대해 0부터 9까지의 버킷을 만든다.
   - 자릿수에 해당하는 숫자에 따라 데이터를 적절한 버킷에 넣고, <br/>
그 버킷에서 데이터를 꺼내어 정렬한다.

3. **반복**
   - 모든 자릿수에 대해 위의 과정을 반복한다.
   - 자릿수가 많을수록 반복 횟수가 늘어난다.

<br/>

- **예시**

![](https://blog.kakaocdn.net/dn/enivd9/btrnN1csrDT/dL9D1I9aWu9vgalzyz54B0/img.png) <br/>
출처: [기수 정렬](https://epser.tistory.com/26)

<br/>

1. 각 원소들 중 최대 자리수를 구한다. 
   - `[1,2,3,10,157]`이라면 `157` ➡︎ 세 자릿수인 `3`이 최대 자리수가 된다.
2. `0 ~ 9`까지의 Queue를 만든다.
3. 각 원소별 자리수의 숫자를 해당하는 번호의 Queue에 집어 넣는다.
4. `0 ~ 9`까지의 Queue를 순회하며 원소를 뽑아 기존 배열에 교체한다.
5. 최대 자리수만큼 `2 ~ 4`를 반복한다.

<br/><br/>
<br/>

## ✅ 계수 정렬 (counting sort)
: **데이터의 개수를 세어서 정렬**하는 정렬 알고리즘
- **비교하지 않는** 정렬 알고리즘
- **장점**
   -  데이터의 범위가 제한적일 때 효율적이다.
- **단점**
   - 데이터 범위에 맞는 크기의 배열을 추가로 생성해야 하므로 메모리 공간이 필요하다.
   - 데이터 범위가 0 이상의 정수여야 한다는 제약이 있다.
     - 범위가 너무 크거나 데이터가 음수인 경우에는 적합하지 않다.

<br/>

### ☑️ 계수 정렬의 작동 방식
1. **빈 배열 생성**
    - **정렬하려는 데이터의 범위에 맞는 크기의 빈 배열을 생성**한다.
       - ex) 데이터 범위가 0부터 99까지라면, 크기가 100인 빈 배열을 만든다.

2. **데이터의 개수 세기**
    - **정렬하려는 배열을 순회하면서 각 데이터 값에 해당하는 인덱스의 값을 1씩 증가**시킨다.
       - ex) 배열 `[4, 2, 2, 8, 3]`가 있을 때, 빈 배열의 인덱스 `4, 2, 8, 3`의 값을 각각 1씩 증가시킨다.

3. **정렬된 배열 생성**
    - **빈 배열에서 각 인덱스의 값이 1인 경우, 해당 인덱스의 값을 정렬된 배열에 추가**한다.
    - 이렇게 해서 데이터가 오름차순으로 정렬된 결과를 얻는다.

<br/>

- **예시**

- 아래와 같은 배열을 가정한다.
```
a = [4, 2, 2, 8, 3, 3, 1];
```

<br/>

1. 주어진 배열의 최대값을 찾는다. 
   - 여기서는 “8”이 된다.
```
max(a) = 8;
```

<br/>

2. 최대값에 1을 더한 만큼의 크기를 가진 갯수 저장용 배열을 생성한다. 
   - 초기에는 모든 값을 0으로 저장하여 초기화한다. 
   - 인덱스는 0부터 시작하므로, 8까지 총 9개의 Slot이 존재한다.
```
count = [0, 0, 0, 0, 0, 0, 0, 0, 0];
```

<br/>

3. 배열 “a”에 저장된 아이템의 갯수를 세어, 그 값을 “count” 배열에 각 아이템에 대응하는 인덱스에 저장한다.
   - 위 배열 “a”에서 3의 빈도는 2가 된다. 
     - 그렇다면, 값 2는 count 의 세 번째 인덱스에 저장된다. 
   - 배열 “a”에 존재하지 않는 값들에 대해서는 해당 값에 대응하는 count 위치의 값이 “0”이 된다.
```
count = [0, 1, 2, 2, 1, 0, 0, 0, 1];
```

<br/>

4. count 배열의 값들을 한 위치에서 다음 위치의 값들을 더하면서, 다음 위치가 이전 위치의 값을 포함하는 누적값을 가지는 배열을 또 하나 만든다. 
   - count 배열에서 3번째 위치에 있는 값 “2”에 이전 위치의 값 “1”을 더한다. 
     - 새로운 누적값을 가진 배열에서는 세 번째 위치에 “3”이 된다. 
   - 4번째 위치에 있는 값은, count 배열의 네 번째 위치의 값까지의 합을 더한 것`(0 + 1 + 2 + 2 = 5)`이다.
```
count_cumulative_sum = [0, 1, 3, 5, 6, 6, 6, 6, 7];
```

<br/>

5. 배열 “a”의 각 값에 해당하는 `count_cumulative_sum` 배열 아이템들의 인덱스를 찾는다. 
   - 배열의 첫 번째 값인 “4”를 `count_cumulative_sum` 배열의 인덱스로 활용하면, `count_cumulative_sum` 배열에서는 5번째 위치의 값인 “6”이 된다. 
   - 정렬된 배열을 생성할 때, 이 값에 해당하는 위치에 배열 “a”의 값을 넣는다. 
     - 새로운 배열의 6번째 위치에 값 “4”가 들어간다.
```
output = [0, 0, 0, 0, 0, 0, 0];

=> output = [0, 0, 0, 0, 0, 4, 0];
```

<br/>

6. 이후에 `count_cumulative_sum`에 있던 해당 위치의 값에서 1을 뺀다. 
   - 5번째에 위치한 “6”에서 1을 빼면 “5”가 된다.
```
count_cumulative_sum = [0, 1, 3, 5, “5”, 6, 6, 6, 7]
```

<br/>

7. 5 ~ 6번의 과정을 반복한다. 
   - 배열 “a”의 다음 두 번째 위치의 값인 “2”를 이용해 `count_cumulative_sum`의 해당 위치의 값을 찾으면 “3”이 된다. 
   - 이후, 이 값에 대응하는 위치의 출력 배열에 배열 “a”의 값을 넣는다. 
      - “2”를 출력 배열의 3번째 위치에 넣는다. 
   - 다시 `count_cumulative_sum`의 해당 위치의 값에서 1을 뺀다. 
      - "3”은 `3 – 1 = 2`가 된다.

```
output = [0, 0, 2, 0, 0, 4, 0];

count_cumulative_sum = [0, 1, “2”, 5, 5, 6, 6, 6, 7];
```

<br/>

8. 배열 “a”의 끝까지 출력 배열에 정렬할 때까지 반복하면, 모든 값들이 순서대로 정렬된 배열을 얻을 수 있다.
```
output = [1, 2, 2, 3, 3, 4, 8];
```

<br/>

출처: [계수 정렬](https://conanmoon.medium.com/%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B3%BC%ED%95%99-%EC%9C%A0%EB%A7%9D%EC%A3%BC%EC%9D%98-%EB%A7%A4%EC%9D%BC-%EA%B8%80%EC%93%B0%EA%B8%B0-%EC%8A%A4%EB%AC%BC-%EB%91%90%EB%B2%88%EC%A7%B8-%EC%9D%BC%EC%9A%94%EC%9D%BC-e65a8b7d872f)

<br/><br/>
<br/>

