
# 📌 최단 거리 알고리즘

<br/>

## 목차
1. [최단 거리 알고리즘](#-최단-거리-알고리즘-1)
2. [다익스트라 알고리즘 (Dijkstra algorithm)](#-다익스트라-알고리즘-dijkstra-algorithm)
3. [벨만-포드 알고리즘 (Bellman-Ford algorithm)](#-벨만-포드-알고리즘-bellman-ford-algorithm)

<br/><br/>

## ✅ 최단 거리 알고리즘
: **그래프에서 정점 간의 최단 거리를 계산하기 위해 사용**되는 알고리즘
- 종류
  - **다익스트라 알고리즘** <br/>
: 특정 정점에서 다른 모든 정점까지의 최단 거리 계산 
    - 양수 가중치 간선만
  - **벨만-포드 알고리즘** <br/>
: 특정 정점에서 다른 모든 정점까지의 최단 거리 계산 
    - 음수 가중치 간선 처리 가능, 음수 사이클 검출 가능
  - **플로이드-워셜 알고리즘** <br/>
: 모든 정점 쌍 간의 최단 거리 계산
    - 음수 가중치 간선 처리 가능

<br/><br/>
<br/>
  
## ✅ 다익스트라 알고리즘 (Dijkstra algorithm)
: **가중치가 양수인 간선**이 있는 그래프에서 **특정 정점에서 다른 정점까지의 최단 거리**를 구하는 알고리즘
- 우선순위 큐를 사용할 경우, 시간 복잡도가 `O((V + E) log V)`이다.

![](https://cdn.chunchu.yonsei.ac.kr/news/photo/201603/21321_9234_5512.JPG) <br/>
출처: [다익스트라(Dijkstra) 알고리즘](https://chunchu.yonsei.ac.kr/news/articleView.html?idxno=21321)


<br/><br/>

### ✨ 다익스트라 알고리즘은 가중치가 음수인 간선이 포함된 그래프에서는 사용이 불가능하다. 
- **계산 오류**
   - 다익스트라 알고리즘은 한 번 방문한 정점의 최단 거리를 확정하고 더 이상 수정하지 않는다. 하지만, 음수 가중치가 있는 경우 더 짧은 경로를 나중에 발견할 수 있다.
- **부정확한 결과**
   - 음수 가중치가 있으면 나중에 더 짧은 경로를 찾더라도, 이미 확정된 거리를 수정할 수 없어서 부정확한 결과가 나올 수 있다.


- 이런 경우에는 **벨만-포드 알고리즘**을 사용하는 것이 적절하다. 
  - 벨만-포드 알고리즘은 음수 가중치를 처리할 수 있으며, 음수 사이클이 존재하는지도 검사할 수 있다.

<br/><br/>

### ☑️ 다익스트라 알고리즘의 작동 방식
1. **시작 정점의 거리를 0으로 설정하고, 나머지 정점의 거리는 무한대(INF)로 설정한다.**
2. **우선순위 큐를 사용하여 현재 정점과 해당 정점까지의 거리를 관리한다.**
3. **현재 정점을 방문하고, 해당 정점과 연결된 모든 정점의 거리를 갱신한다.**
   - 만약 현재 정점을 거쳐 다른 정점으로 가는 비용이 기존 비용보다 적다면, 그 비용으로 갱신한다.
4. **모든 정점을 방문할 때까지 이 과정을 반복한다.**

<br/>

#### ⏩ 예시
![](https://blog.kakaocdn.net/dn/b8Bp7R/btsejKDr2kx/j4iMnss5hg7lzM6gWvZ3xK/img.png) <br/>
출처: [다익스트라(Dijkstra) 알고리즘](https://great-park.tistory.com/133)

<br/>

#### 1. 출발 노드인 1번 노드를 선택하고, 인접 노드인 2번과 3번의 거리를 계산하여 갱신한다.
![](https://blog.kakaocdn.net/dn/cKgr7x/btseqm2ma4z/KUzR3e6SfGvJWnaIIj3ikK/img.png)

<br/>

#### 2. 방문하지 않은 노드 중 가장 짧은 최단 거리 노드인 2번을 선택한다.
- 2번 노드를 거쳐갈 수 있는 다른 노드들(3, 4, 6번)의 테이블 값을 갱신한다.
   - 3번: 1번 → 3번 = 4
      - 3번 노드는 1번 노드를 거치는 것의 비용이 더 싸기 때문에 업데이트를 하지 않는다.
   - 4번: 1번 → 2번 → 4번 = 13
   - 6번: 1번 → 2번 → 6번 = 12
      - 4번, 6번은 기존의 무한값(INF)이 들어있기 때문에 2번 노드를 거치는 경로의 비용으로 테이블 값을 업데이트한다.

![](https://blog.kakaocdn.net/dn/bg3tgo/btsepPcOcSO/2ZhMF97cZQ1luIWEwIGns0/img.png)

<br/>

#### 3. `3, 4, 6번` 노드 중 가장 짧은 최단 거리 노드인 3번을 선택하고, 3번 노드의 경로인 4, 5번의 최단 거리를 갱신한다.
- 4번: 1번 → 3번 → 4번 = 12
- 5번: 1번 → 3번 → 5번 = 9
![](https://blog.kakaocdn.net/dn/bEeeAf/btseqt1otLf/jAfR0JGBMIqUAp9kZJqP50/img.png)

<br/>

#### 4. 위 과정을 반복한다.

![](https://blog.kakaocdn.net/dn/bIKGJA/btsequstFdS/LssWx2fLZo7jkpcnMkXY81/img.png)

<br/><br/>
<br/>

## ✅ 벨만-포드 알고리즘 (Bellman-Ford algorithm)
: **가중치가 음수인 간선이 있는 그래프**에서도 특정 정점에서 다른 정점까지의 최단 거리를 구하는 알고리즘
- **특징**
  - **간선 순회**
     - **그래프의 정점 수를 n**이라고 할 때, 벨만-포드 알고리즘은 **모든 간선을 `n−1`번 반복해서 검사**한다.
     - 이는 최단 경로를 찾기 위해 최대 `n−1`개의 간선을 사용할 수 있기 때문이다.
  - **'음의 간선'이 있는 경우엔 동작하지만, '음의 사이클'이 있는 경우엔 동작하지 않는다.**
     - 음의 사이클이 있으면 최소 비용이 무한하게 줄어들어서 알고리즘을 적용할 수 없다.
     - 만약 n개 이상의 간선을 사용해도 최단 거리가 계속 갱신된다면, 이는 그래프에 음의 사이클이 존재함을 의미한다.

<br/>

#### ⏩ 음의 사이클
: **간선의 가중치 합이 음수가 되는 사이클**
- **왜 문제인가?**
  - 음의 사이클이 존재하면, **사이클을 계속 돌면서 경로의 길이를 무한히 줄일 수 있기 때문에 최단 경로의 개념이 무의미해질 수 있다.**

![ddd](https://github.com/user-attachments/assets/7141d562-c9ff-43a4-8e2b-0082579e343d)


<br/><br/>

### ☑️ 벨만-포드 알고리즘의 작동 방식
1. **시작 정점의 거리를 0으로, 나머지 정점의 거리를 무한대로 설정한다.**
2. **모든 간선을 `n-1`번 반복하며, 정점 간의 최단 거리를 갱신한다.**
   - 전체 간선 n개를 하나씩 확인한다.
   - 각 간선을 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리를 갱신한다.
3. **모든 간선을 한 번 더 순회하여 거리가 더 갱신되면, 음의 사이클이 존재한다고 판단한다.**

<br/>

#### ⏩ 예시

#### 1. 초기화
- 시작 노드인 A의 최소 비용을 0, 직전 노드를 A, 나머지 노드는 INF로 초기화한다.

![](https://goldenrabbit.co.kr/wp-content/uploads/2023/11/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7-2023-11-06-%EC%98%A4%EC%A0%84-9.07.18.png)

<br/>

#### 2. 비용 갱신
- 노드 A에서 A를 거쳐 각 노드 B, C, D, E까지 가는 비용 중 현재까지 구한 최소 비용보다 적은 값이 있는지 확인하고, 현재까지 구한 최소 비용보다 비용이 적다면 갱신한다.
- 예시 표기 방법
  - 해당 정점의 최소 비용; `최소_비용(A)(숫자)`
  - 가중치가 있는 간선: `간선(A, B)(숫자)`
  - 간선이 없는 경우: `INF`

![](https://goldenrabbit.co.kr/wp-content/uploads/2023/11/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7-2023-11-06-%EC%98%A4%EC%A0%84-9.07.18.png)

- `최소_비용(A)(0)` == `최소_비용(A)(0) + 간선(A, A)(0)` <br/>
➡︎ 갱신하지 않음
- `최소_비용(B)(INF)` > `최소_비용(A)(0) + 간선(A, B)(4)` <br/>
➡︎ 최소_비용(B)를 4로 갱신
- `최소_비용(C)(INF)` > `최소_비용(A)(0) + 간선(A, C)(3)` <br/>
➡︎ 최소_비용(C)를 3으로 갱신
- `최소_비용(D)(INF)` == `최소_비용(A)(0) + 간선(A, D)(INF)` <br/>
➡︎ 갱신하지 않음
- `최소_비용(E)(INF)` > `최소_비용(A)(0) + 간선(A, E)(-6)` <br/>
➡︎ 최소_비용(E)를 -6으로 갱신


<br/>

#### 3. 노드 A에서 B를 거쳐 각 노드까지 가는 최소 비용을 갱신한다.

![](https://goldenrabbit.co.kr/wp-content/uploads/2023/11/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7-2023-11-06-%EC%98%A4%EC%A0%84-9.15.01.png)

- `최소_비용(A)(0)` < `최소_비용(B)(4) + 간선(B, A)(INF)` <br/>
➡︎ 갱신하지 않음
- `최소_비용(B)(4)` == `최소_비용(B)(4) + 간선(B, B)(0)` <br/>
➡︎ 갱신하지 않음
- `최소_비용(C)(3)` < `최소_비용(B)(4) + 간선(B, C)(INF)` <br/>
➡︎ 갱신하지 않음
- `최소_비용(D)(INF)` > `최소_비용(B)(4) + 간선(B, D)(5)` <br/>
➡︎ 9로 갱신
- `최소_비용(E)(-6)` < `최소_비용(B)(4) + 간선(B, E)(-6)` <br/>
➡︎ 갱신하지 않음

<br/>

#### 4. 노드 A에서 C를 거쳐 각 노드까지 가는 최소 비용을 갱신한다.
- 노드 C를 거쳐서 B로 가는 새 경로는 기존의 B의 최소 비용보다 크므로 갱신하지 않는다.
- 노드 A에서 D를 거쳐가는 방법은 없으므로 갱신하지 않는다.

![](https://goldenrabbit.co.kr/wp-content/uploads/2023/11/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7-2023-11-06-%EC%98%A4%EC%A0%84-9.17.53.png)

- `최소_비용(A)(0)` < `최소_비용(C)(3) + 간선(C, A)(INF)` <br/>
➡︎ 갱신하지 않음
- `최소_비용(B)(4)` < `최소_비용(C)(3) + 간선(C, B)(2)` <br/>
➡︎ 갱신하지 않음
- `최소_비용(C)(3)` == `최소_비용(C)(3) + 간선(C, C)(0)` <br/>
➡︎ 갱신하지 않음
- `최소_비용(D)(9)` < `최소_비용(C)(3) + 간선(C, D)(INF)` <br/>
➡︎ 갱신하지 않음
- `최소_비용(E)(-6)` < `최소_비용(C)(3) + 간선(C, E)(INF)` <br/>
➡︎ 갱신하지 않음

<br/>

#### 5. 노드 A에서 E를 거쳐 각 노드까지 가는 최소 비용을 갱신한다.
- 모든 최단 경로에 대해 노드의 최소 비용을 체크했으므로, 벨만-포드 알고리즘의 첫 번째 반복이 끝난다.

![](https://goldenrabbit.co.kr/wp-content/uploads/2023/11/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7-2023-11-06-%EC%98%A4%EC%A0%84-9.19.34.png)

- `최소_비용(A)(0)` < `최소_비용(E)(-6) + 간선(E, A)(INF)` <br/>
➡︎ 갱신하지 않음
- `최소_비용(B)(4)` < `최소_비용(E)(-6) + 간선(E, B)(2)` <br/>
➡︎ 갱신하지 않음
- `최소_비용(C)(3)` == `최소_비용(E)(-6) + 간선(E, C)(0)` <br/>
➡︎ -4로 갱신
- `최소_비용(D)(9)` < `최소_비용(E)(-6) + 간선(E, D)(INF)` <br/>
➡︎ 갱신하지 않음
- `최소_비용(E)(-6)` < `최소_비용(E)(-6) + 간선(E, E)(INF)` <br/>
➡︎ 갱신하지 않음

<br/>

#### 6. 위의 과정을 `노드 개수 – 1`번 반복한다고 했으므로 01단계 01단계 ~ 06단계 06단계를 4번 더 반복한다.

![](https://goldenrabbit.co.kr/wp-content/uploads/2023/11/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7-2023-11-06-%EC%98%A4%EC%A0%84-9.20.14.png)

<br/><br/>

### 다익스트라 알고리즘  vs  벨만-포드 알고리즘
- **다익스트라 알고리즘**
   - 매번 방문하지 않은 노드 중 최단 거리가 가장 짧은 노드를 선택한다.
   - 음수 간선이 없다면 최적의 방법을 찾을 수 있다.

<br/>

- **벨만-포드 알고리즘**
   - 매번 모든 간선을 전부 확인한다.
   - 음수 간선이 없다면 최적의 방법을 찾을 수 있다.

<br/><br/>

### 참고

[벨만-포드 알고리즘 예시](https://www.youtube.com/watch?si=sM4KwCdO-Mn5d-ke&v=obWXjtg0L64&feature=youtu.be)

[벨만-포드 알고리즘](https://goldenrabbit.co.kr/2023/11/06/%ec%bd%94%eb%94%a9-%ed%85%8c%ec%8a%a4%ed%8a%b8-%ed%95%a9%ea%b2%a9%ec%9e%90-%eb%90%98%ea%b8%b0-%ea%b7%b8%eb%9e%98%ed%94%84-%ec%b5%9c%eb%8b%a8-%ea%b2%bd%eb%a1%9c-%ea%b5%ac%ed%95%98%ea%b8%b0-%e2%9d%b7/)

[코딩 테스트를 위한 벨만 포드 알고리즘 7분 핵심 요약](https://youtu.be/Ppimbaxm8d8?si=P62NnS_KVv-hp2j6)

<br/><br/>
