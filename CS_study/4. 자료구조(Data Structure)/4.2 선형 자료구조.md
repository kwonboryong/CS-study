
# 📌 선형 자료구조

<br/>

## 목차
1. [선형 자료구조 (linear data structure)](#-HTTP)
2. [제목](#-HTTP)
3. [제목](#-HTTP)
4. [제목](#-HTTP)
5. [제목](#-HTTP)

<br/><br/>

## ✅ 선형 자료구조 (linear data structure)
: 연속적으로 데이터가 나열되는 자료구조
- 하나의 데이터 뒤에 다른 하나의 데이터가 연결된다. 
- 대표적인 선형 자료구조: 배열, 리스트, 스택, 큐 등

![시간 복잡도 – JungHyun Baek – Developer from South Korea](https://raw.githubusercontent.com/junghyun100/junghyun100.github.io/master/images/%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84/%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%842.PNG) <br/>
출처: [시간 복잡도](https://junghyun100.github.io/Time-Complexity/)

<br/><br/>

## ✅ 배열 (array)
: 정해진 크기만큼 데이터가 일렬로 저장되는 정적(static) 자료구조

<br/>

#### ⏩ 요소(element)
: 각 데이터

<br/>

#### ⏩ 인덱스(index)
: 데이터를 가리키는 번호
- 배열의 인덱스는 0부터 ~ 1까지 참조할 수 있다.

<br/><br/>

### ☑️ 데이터 접근
#### ```O(1)```
- 배열에서 특정 인덱스의 데이터에 접근하는 데 걸리는 시간 복잡도는 O(1)이다.
- 이유
  - 배열의 데이터에 접근할 때는 <br/> 배열의 첫 번째 데이터의 주소값에 (데이터 타입의 메모리 크기) × (접근하려는 데이터의 인덱스)를 더하면 된다.

- 구현 방식
  1. 배열의 각 요소는 메모리에서 연속적으로 배치된다.
  2. 특정 인덱스의 데이터에 접근하려면, 배열의 시작 주소에 해당 인덱스에 해당하는 오프셋을 더한다.
  3. 이 연산은 단순한 덧셈으로 이루어지기 때문에, 시간 복잡도는 𝑂(1)이다.

<br/>

### ☑️ 데이터 검색
#### ```O(n)```
- 배열에서 데이터를 검색하는 데 걸리는 시간 복잡도는 O(n)이다.
- 이유
  - 특정 데이터를 검색할 때는 배열의 각 요소를 하나씩 검사해야 하다. 
  - 데이터가 배열의 마지막 인덱스에 있을 때나 데이터가 배열에 존재하지 않는 경우, 모든 인덱스를 탐색해야 하므로 최대 𝑛번의 연산이 필요하다.

- 구현 방식
  1. 배열의 첫 번째 요소(인덱스 0)부터 시작한다.
  2. 각 요소를 검색하려는 데이터와 비교한다.
  3. (1) 데이터가 일치하면 검색을 종료한다.
  3. (2) 데이터가 일치하지 않으면 다음 요소로 이동하여 계속 검색한다.
  4. 데이터가 발견되면 검색을 종료한다.
  5. 배열의 끝까지 탐색해도 데이터를 찾지 못하면 데이터가 배열에 없다고 판단한다.

<br/>

### ☑️ 데이터 삽입
#### ```O(n)``` ```O(1)```
- 배열에서 특정 위치에 새로운 데이터를 삽입하는 시간 복잡도는 O(n), 빈 공간이 있는 경우에는 𝑂(1)이다.
- 이유
  - 배열의 특정 위치에 데이터를 추가하려면, 배열의 모든 요소를 한 칸씩 뒤로 밀어야 하기 때문에 해당 위치 이후의 모든 데이터를 이동시켜야 한다. 
  - 따라서 일반적으로 시간 복잡도는 𝑂(𝑛)이다.

- 구현 방식
  - 데이터 추가
    - 위치 이후 데이터 이동 <br/>
: 예를 들어, 인덱스 4에 데이터 1을 추가할 때, 인덱스 4부터 배열의 끝까지 모든 데이터를 한 칸씩 뒤로 이동시킨다.
    - 새 데이터 삽입 <br/>
: 이동이 완료된 후, 인덱스 4에 새로운 데이터를 삽입한다.

  - 빈 공간이 있는 경우
    - 마지막 위치에 추가 <br/>
: 배열의 마지막 인덱스에 빈 공간이 있는 경우, 데이터가 직접 추가될 수 있다. <br/>
➡︎ 이 경우에는 이동이 필요 없으므로 시간 복잡도는 O(1)이다.

<br/>

### ☑️ 데이터 삭제
#### ```O(n)```
- 배열에서 데이터 삭제 시, 일반적으로는 O(n)의 시간 복잡도를 가지며, 마지막 데이터 삭제 시에는 O(1)이다.
- 이유
  - 배열에서 특정 위치의 데이터를 삭제하면, 삭제한 위치 뒤에 있는 모든 데이터들을 한 칸씩 앞으로 이동시켜야 한다. 
  - 삭제된 위치를 빈 공간으로 만들고, 나머지 데이터를 밀어내어 배열의 연속성을 유지하기 때문이다.
  - 데이터가 배열의 맨 앞에 위치하는 경우, 배열의 모든 데이터를 이동시켜야 하므로 시간 복잡도는 O(n)이다.

- 구현 방식
  - 데이터 삭제
    - 위치 이후 데이터 이동 <br/>
: 예를 들어, 인덱스 2의 데이터 3을 삭제할 때, 인덱스 3부터 배열의 끝까지의 데이터를 한 칸씩 앞으로 이동시킨다.
    - 빈 공간 처리 <br/>
: 삭제된 위치는 빈 공간이 되며, 나머지 데이터는 앞쪽으로 이동하여 배열의 연속성을 유지한다.

  - 마지막 데이터 삭제
    - 마지막 위치 삭제 <br/>
: 삭제하려는 데이터가 배열의 마지막 인덱스에 있을 경우, 배열의 마지막 인덱스에서 데이터를 삭제하면 된다.
    - 시간 복잡도 <br/>
: 마지막 인덱스에서 데이터만 삭제하면 되므로 위치를 바꿔야 하는 데이터가 없으며, 시간 복잡도는 O(1)이다.

<br/><br/>
<br/>

## ✅ 연결 리스트 (linked list)
: 배열과 달리 크기가 정해져 있지 않은 동적(dynamic) 자료구조
- 여러 개의 노드(node)로 구성된다.
- 노드는 데이터와 다음 노드가 저장된 주소 값을 가지고 있다.
- 연결 리스트의 구조
  - 헤드(head) 포인터: 연결 리스트의 시작을 나타낸다. (첫 번째 노드)
  - 테일(tail) 포인터: 연결 리스트의 끝을 나타낸다. (마지막 노드)
  - 첫 번째 노드: 헤드 포인터가 가리키는 노드
    -  이전 노드가 없고, 다음 노드를 가리키는 포인터가 있다.
  - 마지막 노드: 테일 포인터가 가리키는 노드
    -  다음 노드가 없어서 다음 노드를 가리키는 포인터가 NULL이다.
 - 특징
   - 비연속적인 저장 <br/>
: 연결 리스트의 노드들은 메모리에서 연속적으로 저장되지 않아도 된다. 각 노드는 다음 노드의 주소를 가지고 있어 서로 연결된다.
   - 효율적인 추가 및 삭제 <br/>
: 노드를 추가하거나 삭제할 때, 기존 노드들의 위치를 변경할 필요가 없어서 효율적이다. 노드의 링크만 업데이트하면 된다.
 - 단점
   - 데이터 접근 속도 <br/>
: 배열과 달리 연결 리스트는 인덱스를 사용하지 않기 때문에, 특정 위치의 데이터를 찾기 위해서는 처음부터 차례로 노드를 탐색해야 한다. <br/>
➡︎ 이로 인해 데이터 접근 시간이 더 걸린다.

![1-5. [자료구조이론] Linked List (연결 리스트)](https://velog.velcdn.com/images/hyhy9501/post/6ac603fb-4206-4857-a718-42df35c1d012/image.png) <br/>
출처: [연결 리스트](https://velog.io/@hyhy9501/5-1-Linked-List-%EC%97%B0%EA%B2%B0-%EB%A6%AC%EC%8A%A4)

<br/><br/>

### ☑️ 
#### ```ㅇ```


<br/>

### ☑️ 
#### ```ㅇ```



<br/>

### ☑️ 
#### ```ㅇ```



<br/>

### ☑️ 
#### ```ㅇ```



<br/>

### ☑️ 
#### ```ㅇ```





<br/>

#### ⏩ 배열(Array) vs 연결 리스트(Linked List)

![](https://woovictory.github.io/img/arraylist_linkedlist_diff.png) <br/>
출처: [Array vs LinkedList](https://woovictory.github.io/2018/12/27/DataStructure-Diff-of-Array-LinkedList/)

<br/><br/>
<br/>

## ✅ 스택


<br/>

### ☑️ 



<br/><br/>
<br/>

## ✅ 큐


<br/>

### ☑️ 




<br/>

#### ⏩ 


<br/><br/>
