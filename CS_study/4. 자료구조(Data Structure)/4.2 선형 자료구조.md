
# 📌 선형 자료구조

<br/>

## 목차
1. [선형 자료구조 (linear data structure)](#-선형-자료구조-linear-data-structure)
2. [배열 (array)](#-배열-array)
3. [연결 리스트 (linked list)](#-연결-리스트-linked-list)
4. [스택 (stack)](#-스택-stack)
5. [큐 (queue)](#-큐-queue)

<br/><br/>

## ✅ 선형 자료구조 (linear data structure)
: **연속적으로 데이터가 나열되는 자료구조**
- 하나의 데이터 뒤에 다른 하나의 데이터가 연결된다. 
- 대표적인 선형 자료구조: **배열, 리스트, 스택, 큐** 등

![시간 복잡도 – JungHyun Baek – Developer from South Korea](https://raw.githubusercontent.com/junghyun100/junghyun100.github.io/master/images/%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84/%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%842.PNG) <br/>
출처: [시간 복잡도](https://junghyun100.github.io/Time-Complexity/)

<br/><br/>
<br/>

## ✅ 배열 (array)
: 정해진 크기만큼 **데이터가 일렬로 저장**되는 정적(static) 자료구조

<br/>

#### ⏩ 요소(element)
: 각 데이터

<br/>

#### ⏩ 인덱스(index)
: 데이터를 가리키는 번호
- 배열의 인덱스는 0부터 ~ 1까지 참조할 수 있다.

<br/><br/>

### ☑️ 데이터 접근
#### ```O(1)```
- **배열에서 특정 인덱스의 데이터에 접근하는 데 걸리는 시간 복잡도**는 O(1)이다.
- **이유**
  - **배열의 데이터에 접근할 때**는 <br/> 배열의 첫 번째 데이터의 주소값에 (데이터 타입의 메모리 크기) × (접근하려는 데이터의 인덱스)를 더하면 된다.

- **구현 방식**
  1. 배열의 각 요소는 메모리에서 연속적으로 배치된다.
  2. 특정 인덱스의 데이터에 접근하려면, 배열의 시작 주소에 해당 인덱스에 해당하는 오프셋을 더한다.
  3. 이 연산은 단순한 덧셈으로 이루어지기 때문에, 시간 복잡도는 𝑂(1)이다.

<br/>

### ☑️ 데이터 검색
#### ```O(n)```
- 배열에서 데이터를 검색하는 데 걸리는 시간 복잡도는 O(n)이다.
- **이유**
  - **특정 데이터를 검색할 때는 배열의 각 요소를 하나씩 검사해야 하다.**
  - **데이터가 배열의 마지막 인덱스에 있을 때나 데이터가 배열에 존재하지 않는 경우, 모든 인덱스를 탐색해야 하므로 최대 𝑛번의 연산이 필요하다.**

- **구현 방식**
  1. 배열의 **첫 번째 요소(인덱스 0)부터 시작**한다.
  2. **각 요소를 검색하려는 데이터와 비교**한다.
  3. (1) 데이터가 일치하면 검색을 종료한다.
  3. (2) 데이터가 일치하지 않으면 다음 요소로 이동하여 계속 검색한다.
  4. 데이터가 발견되면 검색을 종료한다.
  5. 배열의 끝까지 탐색해도 데이터를 찾지 못하면 데이터가 배열에 없다고 판단한다.

<br/>

### ☑️ 데이터 삽입
#### ```O(n)``` ```O(1)```
- 배열에서 **특정 위치에 새로운 데이터를 삽입**하는 시간 복잡도는 **O(n)**, 빈 공간이 있는 경우에는 **𝑂(1)**이다.
- **이유**
  - **배열의 특정 위치에 데이터를 추가하려면, 배열의 모든 요소를 한 칸씩 뒤로 밀어야 하기 때문에 해당 위치 이후의 모든 데이터를 이동시켜야 한다.**

- **구현 방식**
  - **데이터 추가**
    - **위치 이후 데이터 이동** <br/>
: 예를 들어, 인덱스 4에 데이터 1을 추가할 때, 인덱스 4부터 배열의 끝까지 **모든 데이터를 한 칸씩 뒤로 이동**시킨다.
    - **새 데이터 삽입** <br/>
: 이동이 완료된 후, 인덱스 4에 새로운 데이터를 삽입한다.

  - **빈 공간이 있는 경우**
    - **마지막 위치에 추가** <br/>
: **배열의 마지막 인덱스에 빈 공간이 있는 경우, 데이터가 직접 추가될 수 있다.** <br/>
➡︎ 이 경우에는 **이동이 필요 없으므로** 시간 복잡도는 O(1)이다.

<br/>

### ☑️ 데이터 삭제
#### ```O(n)```
- 배열에서 데이터 삭제 시 일반적으로는 **O(n)**의 시간 복잡도를 가지며, **마지막 데이터 삭제 시에는 O(1)**이다.
- **이유**
  - **배열에서 특정 위치의 데이터를 삭제하면, 삭제한 위치 뒤에 있는 모든 데이터들을 한 칸씩 앞으로 이동시켜야 한다.**
  - **삭제된 위치를 빈 공간으로 만들고, 나머지 데이터를 밀어내어 배열의 연속성을 유지하기 때문이다.**
  - 데이터가 배열의 맨 앞에 위치하는 경우, **배열의 모든 데이터를 이동**시켜야 하므로 시간 복잡도는 O(n)이다.

- **구현 방식**
  - **데이터 삭제**
    - **위치 이후 데이터 이동** <br/>
: 예를 들어, 인덱스 2의 데이터 3을 삭제할 때, 인덱스 3부터 배열의 끝까지의 **데이터를 한 칸씩 앞으로 이동**시킨다.
    - **빈 공간 처리** <br/>
: **삭제된 위치는 빈 공간이 되며, 나머지 데이터는 앞쪽으로 이동하여 배열의 연속성을 유지한다.**

  - **마지막 데이터 삭제**
    - **마지막 위치 삭제** <br/>
: 삭제하려는 데이터가 배열의 마지막 인덱스에 있을 경우, 배열의 마지막 인덱스에서 데이터를 삭제하면 된다.
    - **시간 복잡도** <br/>
: 마지막 인덱스에서 데이터만 삭제하면 되므로 위치를 바꿔야 하는 데이터가 없으며, 시간 복잡도는 O(1)이다.

<br/><br/>
<br/>

## ✅ 연결 리스트 (linked list)
: **크기가 정해져 있지 않은 동적(dynamic) 자료구조**
- 여러 개의 노드(node)로 구성된다.
- 노드는 **데이터와 다음 노드가 저장된 주소 값을 가지고 있다.**
- **연결 리스트의 구조**
  - **헤드(head) 포인터**: 연결 리스트의 시작을 나타낸다. (첫 번째 노드)
  - **테일(tail) 포인터**: 연결 리스트의 끝을 나타낸다. (마지막 노드)
  - **첫 번째 노드**: 헤드 포인터가 가리키는 노드
    -  이전 노드가 없고, 다음 노드를 가리키는 포인터가 있다.
  - **마지막 노드**: 테일 포인터가 가리키는 노드
    -  다음 노드가 없어서 다음 노드를 가리키는 포인터가 NULL이다.
 - **특징**
   - **비연속적인 저장** <br/>
: **연결 리스트의 노드들은 메모리에서 연속적으로 저장되지 않아도 된다. 각 노드는 다음 노드의 주소를 가지고 있어 서로 연결된다.**
   - **효율적인 추가 및 삭제** <br/>
: 노드를 추가하거나 삭제할 때, 기존 노드들의 위치를 변경할 필요가 없어서 효율적이다. **노드의 링크만 업데이트하면 된다.**
 - **단점**
   - **데이터 접근 속도** <br/>
: 배열과 달리 **연결 리스트는 인덱스를 사용하지 않기 때문에 특정 위치의 데이터를 찾기 위해서는 처음부터 차례로 노드를 탐색해야 한다.** <br/>
➡︎ 이로 인해 **데이터 접근 시간이 더 걸린다.**

<br/>

![1-5. [자료구조이론] Linked List (연결 리스트)](https://velog.velcdn.com/images/hyhy9501/post/6ac603fb-4206-4857-a718-42df35c1d012/image.png) <br/>
출처: [연결 리스트](https://velog.io/@hyhy9501/5-1-Linked-List-%EC%97%B0%EA%B2%B0-%EB%A6%AC%EC%8A%A4)

<br/><br/>

### ☑️ 데이터 검색
#### ```O(n)```
- 연결 리스트에서 특정 데이터를 검색하는 데 드는 시간 복잡도는 O(n)이다. 
- **이유**
  - 연결 리스트는 **노드들이 순차적으로 연결**되어 있기 때문에 **특정 데이터를 찾기 위해서는 첫 번째 노드부터 차례로 하나씩 확인해야 한다.**
  - **인덱스가 없어 중간에 바로 접근할 수 없기 때문에 전체 리스트를 탐색해야 할 경우가 많다.** <br/>
➡︎ 그래서 시간 복잡도는 𝑂(𝑛)이다.

- **구현 방식**
  - **첫 번째 노드부터 순차 탐색**  <br/>
: 예를 들어, 리스트에서 데이터 5를 찾으려면 첫 번째 노드(ex. 4)부터 시작해서 <br/> 다음 노드(ex. 3), 그 다음 노드(또 다른 3)까지 차례로 확인해야 한다.
  - **검색 종료** <br/>
: 찾고자 하는 데이터(5)를 발견하면 검색을 종료한다. <br/>
하지만 데이터가 리스트의 끝에 있을 경우, 전체 리스트를 탐색해야 하므로 시간 복잡도는 𝑂(𝑛)이 된다.

<br/>

### ☑️ 데이터 추가
#### ```O(1)```
- 연결 리스트에서 데이터를 추가하는 연산 자체는 O(1)이다.
- **이유**
  - **데이터 추가 자체** <br/>
: 새로운 데이터를 추가할 때, **기존 노드들의 위치를 바꿀 필요가 없다.** <br/>
    - 새 노드를 만들고, 앞뒤 노드의 연결만 바꾸면 되기 때문에 시간 복잡도가 O(1)이다. (이전 노드의 포인터만 변경하면 되기 때문)
  - **위치 탐색** <br/>
: 데이터를 추가하려는 위치까지 가야 하는데, 이 과정에서 시간이 걸린다. <br/>
    - 예를 들어, 리스트 끝에 데이터를 추가하려면, 끝까지 가야 한다.
    - 최악의 경우엔 리스트의 끝까지 탐색해야 하므로 시간 복잡도는 O(n)이 된다.
  - **특정 위치에 추가** <br/>
: 리스트의 맨 앞에 데이터를 넣는 건 첫 번째 노드 앞에 새 노드를 넣기만 하면 되기 때문에 시간 복잡도는 **O(1)**이다.
    - 반면, 중간이나 끝에 데이터를 추가하려면, 그 위치까지 가야 하기 때문에 시간 복잡도는 **O(n)**이다.

- **구현 방식**
  - **맨 앞에 데이터 추가**
    - **포인터 변경** <br/>
: 새로운 노드를 생성한 뒤, 이 노드가 기존의 첫 번째 노드를 가리키도록 포인터를 설정한다. <br/>
그런 다음, 헤드 포인터를 새로운 노드로 변경한다.  <br/>
➡︎ 이 과정은 포인터 변경만으로 이루어지기 때문에 시간 복잡도는 O(1)이다.

  - **중간 또는 끝에 데이터 추가**
    - **위치 탐색** <br/>
: 추가하려는 위치까지 노드를 하나씩 탐색한다. <br/>
      - 예를 들어, 4번째 노드 뒤에 데이터를 추가하려면, 먼저 4번째 노드를 찾아야 한다. <br/>
       ➡︎ 위치 탐색에 O(n)이 걸린다.
    - **포인터 설정** <br/>
: 4번째 노드를 찾은 후, 이 노드와 새 노드 사이의 연결을 바꾼다.
      - 이 노드의 다음 노드 포인터를 새로운 노드가 가리키도록 변경하고, 4번째 노드가 새로운 노드를 가리키도록 한다. <br/>
       ➡︎ 포인터 변경은 O(1)이 걸린다.
    - **시간 복잡도** <br/>
: 위치 탐색에 O(n)이 걸리며, 포인터 변경은 O(1)이기 때문에 전체 시간 복잡도는 O(n)이 된다.

<br/>

### ☑️ 데이터 삭제
#### ```O(1)```
- 연결 리스트에서 첫 번째 데이터를 삭제하는 경우 O(1)이 소요된다.
- **이유**
  - **첫 번째 데이터 삭제** <br/>
: 첫 번째 데이터를 삭제하는 경우, **헤드 포인터를 다음 노드를 가리키도록 바꾸기**만 하면 되기 때문에 시간 복잡도가 O(1)이다.
  - **다른 위치에서 데이터 삭제** <br/>
: 첫 번째 데이터를 제외한 **다른 위치에서 데이터를 삭제하려면 먼저 그 위치까지 가야 한다.** 최악의 경우 리스트의 끝까지 탐색해야 할 수도 있기 때문에 시간 복잡도는 O(n)이다.

- **구현 방식**
  - **첫 번째 데이터 삭제**
    - **포인터 변경** <br/>
: 헤드 포인터를 현재 첫 번째 노드의 다음 노드를 가리키도록 설정한다. <br/>
➡︎ 시간 복잡도는 O(1)이다.
  - **다른 위치에서 데이터 삭제**
    - **위치 탐색** <br/>
: 삭제하려는 노드를 찾기 위해 첫 번째 노드부터 해당 위치까지 순차적으로 탐색한다.
    - **포인터 설정** <br/>
: 삭제할 노드를 찾은 후, 그 노드의 이전 노드가 가리키는 포인터를 삭제할 노드가 가리키고 있던 다음 노드로 변경한다. <br/>
➡︎ 삭제 작업 자체는 **O(1)**이지만, 위치를 찾는 데 **O(n)**이 걸릴 수 있다.

<br/><br/>

#### ⏩ 연결 리스트(Linked List) 종류

![](https://blog.kakaocdn.net/dn/rbem3/btrb78zrZZK/9NkFaMCNXeshwPtdKLaK60/img.png) <br/>
출처: [연결 리스트 종류](https://sxyzn.tistory.com/14)

<br/><br/>

**이중 연결 리스트 (Double Linked List)**
- **구조**
  - 이중 연결 리스트의 **노드는 두 개의 주소 값을 저장**한다. <br/>
하나는 **앞 노드의 주**소를, 다른 하나는 **다음 노드의 주소**를 가리킨다.
- **특징**
  - 이 구조 덕분에 **양방향으로 탐색이 가능**하다. <br/>
단순 연결 리스트와 달리, 노드를 앞쪽이나 뒤쪽 모두에서 검색할 수 있다.
- **장점**
  - 양방향 탐색이 가능하므로 **노드 간 이동이 더 유연**하다.
  - **노드의 연결 순서와 관계없이 원하는 노드로 바로 이동할 수 있다.**
- **단점**
  - 단순 연결 리스트보다 **구현이 복잡**하다.
  - 각 노드가 두 개의 주소 값을 저장해야 하므로 **더 많은 메모리가 필요**하다.
- **예시**
  - 연결 리스트에서 값 3을 찾은 다음 바로 값 7을 찾고자 할 때, <br/>
이중 연결 리스트는 양방향 탐색이 가능해 더 효율적이다.

<br/><br/>

**원형 연결 리스트 (Circular Linked List)**
- **구조**
  - 원형 연결 리스트에서 **마지막 노드는 NULL을 가리키는 대신 첫 번째 노드의 주소를 가리킨다.** 
그래서 리스트의 **노드들이 원형으로 연결**된다.
- **특징**
  - 다른 연결 리스트와 달리, 리스트의 끝이 없고 순환 구조를 이루고 있다. <br/>
**헤드가 마지막 노드를 가리킬 수 있어 삽입과 삭제 연산이 효율적이다.**
- **장점**
  - **새로운 노드를 맨 앞이나 맨 끝에 삽입할 때, 헤드가 이미 마지막 노드를 가리키고 있어서 바로 접근이 가능하다.** <br/>
➡︎ 이로 인해 삽입 연산이 **O(1)**의 시간 복잡도로 빠르게 수행된다.
- **순환 탐색**
  - 리스트가 순환 구조라 **어느 노드에서든 모든 노드에 접근할 수 있다.**
- **예시**
  - **마지막 노드에 새로운 노드를 추가할 때, 기존 노드의 연결을 바꾸는 간단한 연산만으로도 작업이 완료**된다. <br/>
➡︎ 원형 연결 리스트에서 매우 효율적이다.

<br/><br/>

#### ⏩ 배열(Array) vs 연결 리스트(Linked List)

![](https://woovictory.github.io/img/arraylist_linkedlist_diff.png) <br/>
출처: [Array vs LinkedList](https://woovictory.github.io/2018/12/27/DataStructure-Diff-of-Array-LinkedList/)

<br/><br/>
<br/>

## ✅ 스택 (stack)
: **데이터를 쌓는 형태**
- 마지막에 들어온 데이터가 먼저 나가는 **LIFO(Last In First Out, 후입선출) 형태의 자료구조**
- 주로 어떤 **작업의 실행을 취소**할 때, **웹 브라우저에서 뒤로가기** 할 때 등 최근에 처리한 작업들을 하나씩 꺼낼 때 사용한다.

![](https://blog.kakaocdn.net/dn/oSFa7/btsBUBpakEE/wcfINHu4lfNki8GhNKc2q1/img.png) <br/>
출처: [스택](https://engineerinsight.tistory.com/315#google_vignette)

<br/><br/>

### ☑️ 데이터 삽입 (Push)
: **스택에 새로운 데이터를 추가하는 연산**을 push라고 한다. 
- 이 연산은 **스택의 가장 위(top)에 데이터를 저장**한다.
- **구조**
  - 스택은 **top이라는 변수를 이용해 현재 가장 위에 있는 데이터의 위치를 기억**한다. 
  - 이로 인해 **데이터가 추가될 때, top의 위치를 업데이트하며 새로운 데이터를 그 위치에 저장**한다.
- **시간 복잡도**
  - 배열이나 연결 리스트를 이용해 구현할 경우, push 연산은 항상 마지막에 데이터를 추가하므로 시간 복잡도는 O(1)이다.

<br/>

### ☑️ 데이터 삭제 (Pop)
: **스택에서 데이터를 제거하는 연산**을 pop이라고 한다. 
- 이 연산은 **스택에서 가장 마지막에 저장된 데이터를 삭제**한다.
- **구조**
  - **top 변수를 사용하여 가장 마지막에 저장된 데이터를 찾아 삭제**한다. 
  - **이때 top이 가리키는 위치를 하나 감소시킨다.**
- **시간 복잡도**
  - O(1)의 시간 복잡도를 가진다.


![](https://blog.kakaocdn.net/dn/bpQpWC/btsBUBW0jR0/a8QnC1hkCzYqQ5YJd19KE1/img.png) <br/>
출처: [스택 연산](https://engineerinsight.tistory.com/315#google_vignette)

<br/><br/>

#### ⏩ 스택(stack) 구현 방법
- **배열(Array)을 이용한 스택**
   - 배열의 끝부분을 스택의 top으로 간주하여 push나 pop 연산을 수행한다.
   - **배열의 크기가 제한되므로, 스택의 크기도 제한적**이다.


- **연결 리스트(Linked List)를 이용한 스택**
   - 연결 리스트의 맨 앞이나 맨 끝을 top으로 설정하여 push와 pop을 수행한다. 
   - **동적으로 메모리를 사용하므로 스택의 크기에 제한이 없고, 메모리 사용이 더 효율적이**다.

<br/><br/>
<br/>

## ✅ 큐 (queue)
: **데이터가 순차적으로 들어오는 형태**
- 먼저 들어온 데이터가 먼저 나가는 **FIFO(First in First out, 선입선출) 형태의 자료구조**
- 예시
   - **운영체제에서 프로세스가 CPU를 할당받기 전까지 대기하는 준비 큐** 
   - 어떠한 작업을 처리할 때 **작업 요청이 들어온 순서대로 처리**할 때 큐를 사용

![](https://t1.daumcdn.net/cfile/tistory/9929C0495C932BB115) <br/>
출처: [큐](https://galid1.tistory.com/483)

<br/><br/>

### ☑️ 데이터 삽입 (Enqueue)
: **큐에 데이터를 추가하는 연산**을 **인큐(enqueue)**라고 한다. 
- 이 연산은 **큐의 맨 뒤(rear)에 데이터를 삽입**한다.
- **구조**
  - 큐의 맨 뒤에 데이터를 추가하기 위해 **rear 포인터를 사용**한다. 
  - **rear는 새로운 데이터가 추가될 때마다 한 칸씩 뒤로 이동**하며, **새로운 데이터를 그 위치에 삽입**한다.
- **시간 복잡도**
  - 큐의 맨 뒤에 데이터를 추가하는 연산은 데이터 위치를 이동할 필요가 없으므로 O(1)의 시간 복잡도를 가진다.

<br/>

### ☑️ 데이터 삭제 (Dequeue)
: **큐에서 데이터를 제거하는 연산**을 **디큐(dequeue)**라고 한다. 
- 이 연산은 **큐의 맨 앞(front)에 있는 데이터를 삭제**한다.
- **구조**
  - 큐의 맨 앞에 있는 데이터를 제거하기 위해 **front 포인터를 사용**한다. 
  - **front는 데이터가 삭제될 때마다 한 칸씩 뒤로 이동하며, 큐의 다음 데이터를 가리키게 된다.**
- **시간 복잡도**
  - 큐의 맨 앞에서 데이터를 삭제하는 연산도 데이터 위치를 이동할 필요가 없으므로 O(1)의 시간 복잡도를 가진다.

<br/>

![](https://miro.medium.com/v2/resize:fit:736/1*MJE8cRN-EHoFyJJEfFx-Xw.png)

<br/><br/>

#### ⏩ 큐(queue) 구현 방법
- **배열(Array)을 이용한 큐**
   - **큐의 맨 앞과 맨 뒤를 각각 front와 rear로 설정하여, enqueue와 dequeue 연산을 수행한다.**
   - **배열을 사용하면 큐가 가득 찼을 때, 배열의 크기를 증가시키거나 순환 큐(circular queue)를 사용해야 한다.**

- **연결 리스트(Linked List)를 이용한 큐**
   - **rear와 front 포인터를 사용하여 enqueue와 dequeue 연산을 수행**한다.
   - **메모리 공간을 동적으로 사용할 수 있어 큐의 크기에 제한이 없다.**

<br/><br/>

#### ⏩ 배열(Array)로 구현한 큐의 문제점
- **큐가 가득 찼는지 확인하는 방법**
  - 큐를 배열로 구현하면, **rear 인덱스를 사용해 큐가 가득 찼는지 쉽게 확인할 수 있다.**
  - **큐에 데이터를 추가할 때마다 rear가 증가하고, 이 값이 배열의 크기와 같아지면 큐가 가득 찼다고 본다.**
- **인큐/디큐 시 front와 rear 수정**
  - **큐에서 데이터를 추가할 때(enqueue)나 삭제할 때(dequeue), front나 rear 인덱스만 수정하면 된다.**
  - 이 작업은 시간 복잡도가 **O(1)**로, 매우 빠르게 처리된다.
- **큐의 가득 참 상태 오류**
  - **큐가 가득 찬 후 일부 데이터를 삭제하면, rear 인덱스는 여전히 배열의 끝에 머물러 있을 수 있다.**
  - 이 경우, **실제로는 빈 공간이 있지만 rear의 위치 때문에 큐가 가득 찼다고 잘못 판단할 수 있다.**

<br/>

#### ⏩ 순환 큐
:  배열의 끝에 도달해도 배열의 처음으로 돌아가서 데이터를 추가할 수 있는 구조
- 이 방식으로 **큐가 꽉 차는 문제를 해결**할 수 있다.
- **데이터 삽입의 유연성**
  - **배열의 어느 위치에서든 데이터를 유연하게 추가하거나 삭제할 수 있다.**
  - 배열의 시작과 끝이 연결된 것처럼 동작하기 때문에, 큐의 끝에서 다시 처음으로 돌아가 데이터를 추가할 수 있다.
- **장점**
  - 순환 큐를 사용하면 **배열의 공간을 최대한 활용**할 수 있다. 
  - **큐가 가득 찬 상태를 잘못 판단하는 문제를 해결**할 수 있다.

<br/>

---

<br/>

#### ⏩ 덱 (deque, double-ended queue)
: **양쪽 끝에서 데이터의 삽입과 삭제가 모두 가능한 자료구조**
- **큐 + 스택을 합친 형태**

![](https://www.cwn.kr/news/data/2021/04/29/p179564644542044_939.png) <br/>
출처: [덱](https://www.cwn.kr/news/articleView.html?idxno=3407)

<br/><br/>

