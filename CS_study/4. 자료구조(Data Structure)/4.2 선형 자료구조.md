
# 📌 선형 자료구조

<br/>

## 목차
1. [선형 자료구조 (linear data structure)](#-HTTP)
2. [제목](#-HTTP)
3. [제목](#-HTTP)
4. [제목](#-HTTP)
5. [제목](#-HTTP)

<br/><br/>

## ✅ 선형 자료구조 (linear data structure)
: 연속적으로 데이터가 나열되는 자료구조
- 하나의 데이터 뒤에 다른 하나의 데이터가 연결된다. 
- 대표적인 선형 자료구조: 배열, 리스트, 스택, 큐 등

![시간 복잡도 – JungHyun Baek – Developer from South Korea](https://raw.githubusercontent.com/junghyun100/junghyun100.github.io/master/images/%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84/%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%842.PNG) <br/>
출처: [시간 복잡도](https://junghyun100.github.io/Time-Complexity/)

<br/><br/>

## ✅ 배열 (array)
: 정해진 크기만큼 데이터가 일렬로 저장되는 정적(static) 자료구조

<br/>

#### ⏩ 요소(element)
: 각 데이터

<br/>

#### ⏩ 인덱스(index)
: 데이터를 가리키는 번호
- 배열의 인덱스는 0부터 ~ 1까지 참조할 수 있다.

<br/><br/>

### ☑️ 데이터 접근
#### ```O(1)```
- 배열에서 특정 인덱스의 데이터에 접근하는 데 걸리는 시간 복잡도는 O(1)이다.
- 이유
  - 배열의 데이터에 접근할 때는 <br/> 배열의 첫 번째 데이터의 주소값에 (데이터 타입의 메모리 크기) × (접근하려는 데이터의 인덱스)를 더하면 된다.

- 구현 방식
  1. 배열의 각 요소는 메모리에서 연속적으로 배치된다.
  2. 특정 인덱스의 데이터에 접근하려면, 배열의 시작 주소에 해당 인덱스에 해당하는 오프셋을 더한다.
  3. 이 연산은 단순한 덧셈으로 이루어지기 때문에, 시간 복잡도는 𝑂(1)이다.

<br/>

### ☑️ 데이터 검색
#### ```O(n)```
- 배열에서 데이터를 검색하는 데 걸리는 시간 복잡도는 O(n)이다.
- 이유
  - 특정 데이터를 검색할 때는 배열의 각 요소를 하나씩 검사해야 하다. 
  - 데이터가 배열의 마지막 인덱스에 있을 때나 데이터가 배열에 존재하지 않는 경우, 모든 인덱스를 탐색해야 하므로 최대 𝑛번의 연산이 필요하다.

- 구현 방식
  1. 배열의 첫 번째 요소(인덱스 0)부터 시작한다.
  2. 각 요소를 검색하려는 데이터와 비교한다.
  3. (1) 데이터가 일치하면 검색을 종료한다.
  3. (2) 데이터가 일치하지 않으면 다음 요소로 이동하여 계속 검색한다.
  4. 데이터가 발견되면 검색을 종료한다.
  5. 배열의 끝까지 탐색해도 데이터를 찾지 못하면 데이터가 배열에 없다고 판단한다.

<br/>

### ☑️ 데이터 삽입
#### ```O(n)``` ```O(1)```
- 배열에서 특정 위치에 새로운 데이터를 삽입하는 시간 복잡도는 O(n), 빈 공간이 있는 경우에는 𝑂(1)이다.
- 이유
  - 배열의 특정 위치에 데이터를 추가하려면, 배열의 모든 요소를 한 칸씩 뒤로 밀어야 하기 때문에 해당 위치 이후의 모든 데이터를 이동시켜야 한다. 
  - 따라서 일반적으로 시간 복잡도는 𝑂(𝑛)이다.

- 구현 방식
  - 데이터 추가
    - 위치 이후 데이터 이동 <br/>
: 예를 들어, 인덱스 4에 데이터 1을 추가할 때, 인덱스 4부터 배열의 끝까지 모든 데이터를 한 칸씩 뒤로 이동시킨다.
    - 새 데이터 삽입 <br/>
: 이동이 완료된 후, 인덱스 4에 새로운 데이터를 삽입한다.

  - 빈 공간이 있는 경우
    - 마지막 위치에 추가 <br/>
: 배열의 마지막 인덱스에 빈 공간이 있는 경우, 데이터가 직접 추가될 수 있다. <br/>
➡︎ 이 경우에는 이동이 필요 없으므로 시간 복잡도는 O(1)이다.

<br/>

### ☑️ 데이터 삭제
#### ```O(n)```
- 배열에서 데이터 삭제 시, 일반적으로는 O(n)의 시간 복잡도를 가지며, 마지막 데이터 삭제 시에는 O(1)이다.
- 이유
  - 배열에서 특정 위치의 데이터를 삭제하면, 삭제한 위치 뒤에 있는 모든 데이터들을 한 칸씩 앞으로 이동시켜야 한다. 
  - 삭제된 위치를 빈 공간으로 만들고, 나머지 데이터를 밀어내어 배열의 연속성을 유지하기 때문이다.
  - 데이터가 배열의 맨 앞에 위치하는 경우, 배열의 모든 데이터를 이동시켜야 하므로 시간 복잡도는 O(n)이다.

- 구현 방식
  - 데이터 삭제
    - 위치 이후 데이터 이동 <br/>
: 예를 들어, 인덱스 2의 데이터 3을 삭제할 때, 인덱스 3부터 배열의 끝까지의 데이터를 한 칸씩 앞으로 이동시킨다.
    - 빈 공간 처리 <br/>
: 삭제된 위치는 빈 공간이 되며, 나머지 데이터는 앞쪽으로 이동하여 배열의 연속성을 유지한다.

  - 마지막 데이터 삭제
    - 마지막 위치 삭제 <br/>
: 삭제하려는 데이터가 배열의 마지막 인덱스에 있을 경우, 배열의 마지막 인덱스에서 데이터를 삭제하면 된다.
    - 시간 복잡도 <br/>
: 마지막 인덱스에서 데이터만 삭제하면 되므로 위치를 바꿔야 하는 데이터가 없으며, 시간 복잡도는 O(1)이다.

<br/><br/>
<br/>

## ✅ 연결 리스트


<br/>

### ☑️ 




<br/>

#### ⏩ 배열(Array) vs 연결 리스트(Linked List)

![](https://woovictory.github.io/img/arraylist_linkedlist_diff.png) <br/>
출처: [Array vs LinkedList](https://woovictory.github.io/2018/12/27/DataStructure-Diff-of-Array-LinkedList/)

<br/><br/>
<br/>

## ✅ 스택


<br/>

### ☑️ 



<br/><br/>
<br/>

## ✅ 큐


<br/>

### ☑️ 




<br/>

#### ⏩ 


<br/><br/>
