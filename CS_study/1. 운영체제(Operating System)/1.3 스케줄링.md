
# 📌 스케줄링

<br/>

## 목차
1. [스케줄링](#-스케줄링)
2. [스케줄링 단계](#-스케줄링-단계)
3. [스케줄링 알고리즘](#-스케줄링-알고리즘)

<br/><br/>

## ✅ 스케줄링 

: 작업(Task) 또는 프로세스(Process)를 **어떤 순서로 실행할지**를 결정하는 과정
- 스케줄링은 운영 체제(OS)의 핵심 기능 중 하나로, CPU나 메모리 같은 자원을 여러 프로세스들이 효율적으로 나눠서 사용할 수 있도록 관리한다.

- 멀티 프로세스 환경에서는 여러 프로세스가 모두 실행되어야 하지만, CPU 자원은 한정적이다. 
그래서 스케줄링을 통해 모든 프로세스를 공평하게 실행해 한정된 자원을 효율적으로 활용하는 것이 OS의 주요 목적이다.

<br/><br/>

### ☑️ 스케줄링 목적

- **공평성**
  - 모든 프로세스가 공평하게 실행되어야 한다. 
  - 특정 프로세스가 실행되지 않는 경우가 없도록 스케줄링해야 한다.

- **효율성**
  - 자원을 효율적으로 사용해 자원이 사용되지 않는 시간이 없도록 스케줄링해야 한다.

- **안정성**
  - 우선순위를 고려해 높은 우선순위의 프로세스를 먼저 처리하도록 스케줄링해야 한다.

- **반응 시간 보장**
  - 프로세스가 오랜 시간 응답이 없으면 사용자는 시스템이 멈춘 것으로 보기 때문에 일정 시간 내에 응답할 수 있도록 스케줄링해야 한다.

- **무한 연기 방지**
  - 특정 프로세스에 대한 처리가 무한히 연기되지 않도록 스케줄링해야 한다.

<br/><br/>
<br/>
  
## ✅ 스케줄링 단계
- **장기 스케줄링(long-term scheduling)** <br/>
: **준비 큐에 어떤 프로세스를 넣을지 결정해 메모리에 올라가는 프로세스 수를 조절**한다. 
  - **잡 스케줄링(job scheduling)** 또는 **승인 스케줄링(admission scheduling)**이라고도 한다. 
  - 현대 운영체제에서는 시분할 시스템을 사용하기 때문에 대부분 사용하지 않는다 ❌

<br/>

- **중기 스케줄링(mid-term scheduling**)** <br/>
: **메모리에 로드된 프로세스 수를 동적으로 조절**한다. 
  - 메모리에 프로세스가 많이 로드되면, 스왑 아웃(swap out)해서 일부 프로세스를 통째로 저장한다. 
  - 스왑 아웃된 프로세스는 중단 상태(suspended)가 된다. 
    - 중단 상태는 2가지로 구분된다.
      - 준비 상태에서 스왑 아웃된 ‘중단된 준비 상태’ 
      - 대기 상태에서 스왑 아웃된 ‘중단된 대기 상태’

<br/>

- **단기 스케줄링(short-term scheduling)** <br/>
: 준비 큐에 있는 **대기 상태 프로세스 중 어떤 프로세스를 다음으로 실행할지 스케줄링 알고리즘으로 결정**한다. 
  - 어떤 프로세스를 디스패치할지 결정하는데, 이를 **CPU 스케줄링**이라고도 한다.

<br/>

![](https://thebook.io/img/080367/043_1.jpg) <br/>
출처: [스케줄링 단계](https://thebook.io/img/080367/043_1.jpg)

<br/><br/>

#### ⏩ 스와핑(swapping)
- **스왑 아웃(swap out)** <br/>
: 메모리 공간보다 많은 프로세스가 로드되었을 때, 사용하지 않는 프로세스를 저장 공간(SSD 등)으로 통째로 옮겨서 일시적으로 메모리에서 빼는 작업

- **스왑 인(swap in)** <br/>
: 스왑 아웃한(저장 공간으로 옮겨졌던) 프로세스가 다시 필요할 때, 해당 프로세스를 통째로 다시 메모리로 불러오는 작업

- **스와핑(swapping)** <br/>
: 프로세스를 통째로 메모리 영역과 저장 공간으로 옮기는 작업
  - 스와핑하면 메모리 공간보다 많은 프로세스를 실행할 수 있다.
  - ex) 스왑 아웃(swap out), 스왑 인(swap in)

<br/>

![](https://thebook.io/img/080367/044.jpg) <br/>
출처: [스와핑](https://thebook.io/img/080367/044.jpg)

<br/><br/><br/>

### ☑️ 프로세스 스케줄링 과정

1. 스케줄러가 준비 큐에 있는 프로세스 중 하나를 선택해 CPU에 디스패치한다. 
   - 이때 스케줄링 알고리즘을 이용한다.

2. CPU에서 프로세스를 실행한다. 
   - 이때 프로세스는 실행 상태다.
      - A: 프로세스 수행이 완료되면 프로세스를 종료한다.
      - B: 일정 시간을 초과하면 인터럽트가 발생해 프로세스가 준비 큐로 들어가고 준비 상태가 된다.
      - C: 입출력 요청이 들어오면 인터럽트가 발생한다. <br/>
      이때 프로세스는 대기 큐로 들어가서 대기 상태가 된다. <br/> 입출력이 완료되면 프로세스는 준비 큐로 들어간다.

3. fork()가 호출되면 자식 프로세스가 생성되고, 자식 프로세스는 준비 큐로 들어간다.

<br/>

![](https://thebook.io/img/080367/043_2.jpg) <br/>
출처: [프로세스 스케줄링 과정](https://thebook.io/img/080367/043_2.jpg)

<br/><br/>
<br/>

## ✅ 스케줄링 알고리즘
: CPU 스케줄러(단기 스케줄러)가 준비 큐에 있는 프로세스 중 어떤 프로세스를 실행시킬지 결정하는 데 사용한다.
- 스케줄링 알고리즘은 비선점형과 선점형으로 나뉜다.

<br/>

#### ⏩ 스케줄링 알고리즘 기준
- **CPU 사용률** <br/>
: CPU를 놀리지 않고 사용하는지 판단

- **처리량** <br/>
: 단위 시간(time unit)당 실행한 프로세스 수
 
- **응답 시간** <br/>
: 프로세스에 요청이 발생했을 때 응답까지 걸리는 시간

- **반환 시간** <br/>
: 프로세스가 로드된 이후부터 종료될 때까지 걸리는 시간

- **대기 시간** <br/>
: 프로세스가 대기 큐에서 대기하는 시간의 총합

<br/><br/>


### ☑️ 비선점형 (non-preemptive scheduling)
: 실행 중인 프로세스가 종료될 때까지 다른 프로세스를 실행할 수 없다 ❌

- **FCFS 스케줄링 (First-Come, First-Served Scheduling)** <br/>
: 준비 큐에 **먼저 들어온 프로세스**가 우선순위를 갖는 알고리즘
  - 준비 큐에 먼저 들어온 프로세스(first come)를 먼저 실행(first served)한다.

<br/>

- **SJF 스케줄링 (Shortest Job First Scheduling)** <br/>
: **실행 시간이 짧은 프로세스**가 우선순위를 갖는 알고리즘
  - **SJN(Shortest Job Next) 스케줄링**이라고도 한다. 
  - 준비 큐에 있는 프로세스 중 CPU를 점유하는 실행 시간이 가장 짧은 프로세스(shortest job)부터 실행한다. 
  - 장점: 평균 대기 시간이 가장 짧다.
  - 단점: 실행 시간이 긴 프로세스는 실행 시간이 짧은 프로세스에 밀려 기아 상태가 될 수 있다.

<br/>

* 기아 상태(starvation) <br/>
: 프로세스마다 우선순위(priority)가 있는데, 우선순위가 높은 프로세스만 수행되어 우선순위가 낮은 특정 프로세스는 계속 실행되지 못하는 것

<br/><br/>

### ☑️ 선점형 (preemptive scheduling)
: 스케줄러가 실행 중인 프로세스를 중단시키고 다른 프로세스를 실행할 수 있다 ⭕

- **RR 스케줄링 (Round Robin)** <br/>
: **모든 프로세스를 순서대로 일정 시간 동안 실행**하는 알고리즘
  - 비선점형 스케줄링과 달리 프로세스 간 우선순위 없이 모든 프로세스가 돌아가며 실행된다. 
  - 일정 시간을 초과하면 다른 프로세스를 실행한다.
    - 여기서 일정 시간은 ‘시간 단위’를 의미하며 타임 퀀텀(time quantum) 또는 타임 슬라이스(time slice)라고도 한다. 
    - 일반적으로 시간 단위는 10~100 밀리초다. 
  - 장점: 모든 프로세스가 반복 수행되어 응답 속도가 빠르다. 
  - 단점: 콘텍스트 스위칭이 빈번하게 일어나서 오버헤드가 크다.

<br/>

- **SRTF 스케줄링 (Shortest Remaining Time First)** <br/>
: 준비 큐에서 **대기 시간이 가장 짧게 남은 프로세스**를 우선 수행하는 알고리즘
  - 한 프로세스가 실행 중일 때, 실행 시간이 더 짧은 프로세스가 준비 큐에 들어오면 실행 시간이 더 짧은 프로세스에게 CPU를 양보해야 한다.
  - 장점: 평균 대기 시간이 짧다.
  - 단점: 수행 시간이 긴 프로세스는 기아 상태가 되기 쉽다.

 <br/>

- **멀티 레벨 스케줄링** <br/>
: **준비 큐를 목적에 따라 여러 개로 분리**해 사용하는 알고리즘
  - 분리한 큐는 각각 우선순위가 있고 각자 다른 스케줄링 알고리즘을 적용할 수 있다. 
  - 여러 개의 큐는 foreground 큐와 background 큐로 나뉜다. 
    - **foreground 큐** ➡️ 응답 속도가 중요한 프로세스가 들어감
    - **background 큐** ➡️ 응답 속도보다 성능을 중요시하는 프로세스가 들어감


<br/><br/>
