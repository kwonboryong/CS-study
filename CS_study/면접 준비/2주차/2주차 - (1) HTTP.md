# 컴퓨터 네트워크 스터디 2주차 - HTTP

- [HTTP 프로토콜(HyperText Transfer Protocol)](#http-프로토콜hypertext-transfer-protocol)
- [HTTP의 요청/응답 모델](#http의-요청응답-모델)
- [HTTP 메서드 중 GET과 POST의 차이점](#http-메서드-중-get과-post의-차이점)
- [HTTP 메서드 중 PUT과 PATCH의 차이점](#http-메서드-중-put과-patch의-차이점)
- [HTTP 상태 코드](#http-상태-코드)
- [HTTP 헤더](#http-헤더)
- [HTTP의 무상태성(Stateless)](#http의-무상태성stateless)
- [HTTP Keep-Alive](#http-keep-alive)
- [HTTP 파이프라이닝](#http-파이프라이닝)
- [HTTP/1.1, HTTP/2, HTTP/3 각각의 특징](#http11-http2-http3-각각의-특징)

<br/><br/>

---

## HTTP 프로토콜(HyperText Transfer Protocol)
: 웹에서 클라이언트와 서버 간 데이터를 주고받기 위한 프로토콜
- **클라이언트가 HTTP 메서드로 서버에게 요청을 보내면, 서버는 HTTP 상태코드로 응답하는 방식으로 동작한다.**
- 주로 텍스트, 이미지, 비디오 등 다양한 리소스를 전송하는 데 사용된다.
- HTTP는 **비상태적(stateless) 프로토콜**로, 요청 간의 상태를 저장하지 않으며 각 요청이 독립적으로 처리된다.

<br/><br/>

---

## HTTP의 요청/응답 모델
- 클라이언트가 서버에게 요청하고 응답받는 모델이다.
- HTTP는 **요청(request)과 응답(response)** 모델로 동작한다. 
- 클라이언트가 요청을 보내면 서버가 응답을 반환하는 구조이다.
- 작동 과정
   1. **클라이언트는 HTTP 메서드, 헤더, 바디와 함께 서버에게 HTTP 요청을 보낸다.**

   2. **서버는 클라이언트가 보낸 HTTP 메서드, 헤더, 바디에 따른 처리를 수행한 후 상태 코드를 통해 HTTP 응답을 클라이언트에게 보낸다.** 

   3. **클라이언트는 서버로부터 받는 응답을 처리한다. 예를 들어 HTML을 응답 받았을 경우 화면에 렌더링 한다.**

<br/>

### 클라이언트의 요청(Request) 구조
- **요청 메서드:** 작업의 종류를 지정하며, 대표적으로 GET(조회), POST(생성), PUT(수정), DELETE(삭제) 등이 있다.
- **헤더(Header)**: 요청에 대한 메타 정보를 담고 있다.
- **바디(Body):** 실제 전송하고자 하는 데이터를 포함한다.

<br/>

### 서버의 응답(Response) 구조
- **상태 코드**: HTTP 버전, 상태 코드(200, 404 등), 상태 메시지 등 요청에 대한 처리 결과를 나타낸다.
- **헤더(Header)**: 응답에 대한 메타 정보를 포함한다.
- **바디(Body)**: 실제 응답 데이터를 포함한다.

<br/><br/>

---

## HTTP 메서드 중 GET과 POST의 차이점

### GET 메서드
: 서버에서 데이터를 조회할 때 사용되는 메서드

<br/>

### POST 메서드
: 서버에 데이터를 제출하여 리소스를 생성하거나 서버의 상태를 변경할 때 사용되는 메서드

<br/>

### GET과 POST의 차이점
- **데이터 전송 방식**
    - **GET:** URL의 쿼리스트링으로 데이터 전송한다. (URL?name=value)
    - **POST:** HTTP 요청의 Body에 데이터 전송한다.
- **데이터 크기 제한**
    - **GET:** URL 길이 제한이 있어 전송 데이터 크기가 제한적이다.
    - **POST**: HTTP Body를 통해 전송하므로 대용량 데이터 전송이 가능하다.
- **보안**
    - **GET:** URL에 데이터가 노출되어 보안에 취약하다.
    - **POST:** Body에 데이터를 담아 전송하므로 GET보다 상대적으로 안전하다.
- **캐싱**
    - **GET:** 캐싱이 가능하다. (→ 브라우저 히스토리에 남음 O)
    - **POST:** 캐싱이 불가능하다. (→ 브라우저 히스토리에 남지 않음 X)
- **용도**
    - **GET:** 데이터 조회(READ)에 사용된다.
    - **POST:** 새로운 리소스 생성(CREATE)에 사용된다.

<br/><br/>

---

## HTTP 메서드 중 PUT과 PATCH의 차이점

### PUT 메서드
: 서버의 자원을 전체적으로 업데이트할 때 사용되는 메서드

<br/>

### PATCH 메서드
: 서버의 자원을 부분적으로 업데이트할 때 사용되는 메서드

<br/>

### PUT과 PATCH의 차이점
- **리소스 업데이트 방식**
    - **PUT**: 리소스의 모든 정보를 한 번에 업데이트한다. (전체 교체)
    - **PATCH**: 리소스의 일부 정보만 선택적으로 업데이트한다. (부분 수정)
- **멱등성(Idempotency)**
    - **PUT**: 멱등하다. (⇒ 여러 번 호출해도 결과가 동일하다.)
    - **PATCH**: 멱등하지 않다. (⇒ 호출할 때마다 결과가 달라질 수 있다.)
- **사용 예시**
    - **PUT**: 사용자의 전체 정보를 업데이트할 때 사용한다.
    - **PATCH**: 사용자의 일부 정보만 업데이트할 때 사용한다.

<br/><br/>

---

## HTTP 상태 코드

### HTTP 상태 코드
: 서버가 클라이언트의 요청을 처리한 결과를 숫자로 표현한 것
- 100번대부터 500번대까지 5개의 클래스로 구분된다.

<br/>

### 주요 HTTP 상태 코드
- **200 (OK)**: 요청이 성공적으로 처리되었음을 나타낸다.
- **201 (Created)**: 요청이 성공적으로 처리되었고, 새로운 리소스가 생성되었음을 의미한다.
- **404 (Not Found)**: 요청한 리소스를 찾을 수 없음을 의미한다.
- **500 (Internal Server Error)**: 서버 내부에서 오류가 발생하여 요청을 처리할 수 없음을 나타낸다.

<br/><br/>

---

## HTTP 헤더

### HTTP 헤더
: HTTP 통신에서 요청이나 응답에 대한 추가 정보를 담고 있는 필드
- `key: value` 형태로 구성된다.

<br/>

### 주요 HTTP 헤더
- **Content-Type**: 전송되는 데이터의 형식을 지정한다. <br/>
(ex. `application/json`, `text/html`)
- **Authorization**: 클라이언트가 인증 정보를 제공할 때 사용된다. <br/>
(ex. `Bearer <token>`)
- **User-Agent**: 요청을 보낸 클라이언트 소프트웨어의 정보를 나타낸다. <br/>
(ex. 브라우저 종류나 버전)
- **Accept**: 클라이언트가 수신할 수 있는 미디어 타입을 지정한다. <br/>
(ex. `application/json`)
- **Cache-Control**: 요청과 응답의 캐싱 방식을 지정한다. <br/>

<br/><br/>

---

## HTTP의 무상태성(Stateless)
: 서버가 클라이언트의 정보를 유지하지 않는 특성
- HTTP는 **무상태 프로토콜**로, 각 요청이 서로 독립적이며 이전 요청의 상태를 기억하지 않는다.
- 클라이언트가 여러 번 요청을 보내더라도, 서버는 각 요청을 개별적으로 처리하고 이전 요청에 대한 정보를 유지하지 않는다.
- 그렇기 때문에 요청 간의 연속성을 유지하려면, 쿠키, 세션 또는 토큰 같은 기술이 필요하다. (로그인, 장바구니 기능 등)

<br/><br/>

---

## HTTP Keep-Alive

### HTTP Keep-Alive
: 한 번 맺은 TCP 연결을 여러 HTTP 요청/응답에 재사용하는 기능
- HTTP/1.1에서 도입된 연결 재사용 메커니즘
    - 기본적으로 HTTP/1.0에서는 요청마다 새로운 TCP 연결을 열고 닫았지만, Keep-Alive를 사용하면 동일한 연결로 여러 요청과 응답을 주고받을 수 있다.
- **장점**
    - 연결 수립에 필요한 시간을 절약할 수 있다.
    - 네트워크 리소스를 효율적으로 사용할 수 있다.

<br/><br/>

---

## HTTP 파이프라이닝

### HTTP 파이프라이닝
: 요청에 대한 응답을 받기 기다리지 않고 여러 개의 요청을 보내는 방식
- 응답은 요청 순서대로 반환되어야 한다. (FIFO)
- **장점**
    - 요청마다 응답을 기다리지 않고, **동시에 여러 요청을 전송**할 수 있다.
    
- **단점**
    - 한 요청이 지연되면 뒤이은 요청들도 지연되는 문제가 있다. 
    → 현재는 거의 사용되지 않으며, HTTP/2의 멀티플렉싱으로 대체되었다.

<br/><br/>

---

## HTTP/1.1, HTTP/2, HTTP/3 각각의 특징

### HTTP/1.1
- **Keep-Alive 도입으로** 연결을 재사용해 성능을 개선되었다.
- **파이프라이닝 기능 도입으로** 요청을 순차적으로 보내지 않고, 한꺼번에 여러 요청을 보내는 방식이 가능하나 잘 사용되지 않는다.
- **호스트 헤더가 추가되어** 하나의 IP로 여러 도메인을 운영할 수 있다.

<br/>

### HTTP/2
- **멀티플렉싱(Multiplexing)을 지원하여** 단일 연결로 동시에 여러 요청과 응답을 주고받을 수 있다.
- **헤더 압축 기능을 통해** 헤더 크기를 줄여 데이터 전송량을 절감할 수 있다.
- **서버 푸시(Server Push) 기능으로** 서버가 클라이언트 요청 전에 필요한 리소스를 미리 전송할 수 있다.
- 데이터를 **이진(binary) 형식**으로 전송해 효율성을 높인다.

<br/>

### HTTP/3
- **QUIC 프로토콜 기반**으로 한다.
- UDP 위에서 작동하여 연결 설정이 빠르고, 멀티플렉싱도 개선되어 특정 요청의 지연이 다른 요청에 영향을 주지 않는다.
- **연결 복원 기능이 있어** 네트워크가 바뀌어도 연결을 유지할 수 있어, 모바일 환경에서 특히 유리하다.


<br/><br/>
<br/>
