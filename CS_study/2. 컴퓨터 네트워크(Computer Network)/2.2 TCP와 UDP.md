
# 📌 TCP와 UDP

<br/>

## 목차
1. [네트워크](#-네트워크(network))
2. [OSI 7계층](#-OSI-7계층)
3. [TCP/IP 4계층](#-TCP/IP-4계층)

<br/><br/>

## ✅ TCP (Transmission Control Protocol)
: 전송 계층에 해당하는 네트워크 프로토콜
- 연결형 서비스를 지원하고, 데이터의 신뢰성을 보장한다.
- 송신부와 수신부의 연결을 확인하는 연결형 서비스다.
- 패킷 교환 방식은 패킷이 전달되는 회선이 정해져 있는 가상 회선 방식이다.
- 패킷의 전송 순서가 보장된다.
- 패킷의 수신 여부를 확인한다.
- 송신부와 수신부는 1:1 통신을 한다.
- 데이터 손실이 없음을 보장하므로 신뢰성이 높다.
- 데이터의 송수신 속도가 느리다.

<br/>

### ☑️ 패킷(packit) 교환 방식
: 가장 많이 사용하는 데이터 통신 방식

- 가상 회선 방식 <br/>
: 데이터를 주고받기 전에 패킷을 전송할 경로인 가상 회선을 설정해서 모든 패킷을 같은 경로로 전송하는 방식
https://woovictory.github.io/img/virtual_circut_packet.png


- 데이터그램 방식 <br/>
: 패킷마다 최적의 경로로 전송되는 방식
  - 송신부에서 보낸 패킷의 순서와 수신부에 도착하는 패킷의 순서가 다를 수 있다.

https://woovictory.github.io/img/datagram_packet.png

<br/>

✨ [패킷(packet)](https://github.com/kwonboryong/CS_study/blob/main/CS_study/2.%20%EC%BB%B4%ED%93%A8%ED%84%B0%20%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC(Computer%20Network)/2.1%20%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%20%EA%B3%84%EC%B8%B5.md#-%EA%B8%B0%ED%83%80-%EC%9A%A9%EC%96%B4)
: 네트워크에서 주고받는 데이터를 작게 분할한 단위


<br/><br/>
<br/>
  
## ✅ TCP 핸드셰이킹(handshaking)
- TCP에서는 연결형 서비스를 지원하기 위해 송신부와 수신부 간의 연결을 설정하고 종료하는 과정을 거친다. 
- 연결 시작 👉 3 –way 핸드셰이킹 사용
- 연결 종료 👉 4 –way 핸드셰이킹 사용

<br/>

#### ⏩ 플래그(flag) 값
: 핸드셰이킹 과정에서는 송신부와 수신부 간 연결 관리를 위해 플래그(flag) 값을 주고 받는다. <br/>
주로 SYN, FIN, ACK를 사용한다.

- **SYN (Synchronization)**: 송신자가 연결 요청을 보낼 때 사용
- **FIN (Finish)**: 송신자가 연결 종료를 요청할 때 사용
- **ACK (Acknowledgment)**: 수신자가 데이터가 성공적으로 수신되었음(FIN 패킷 수신)을 확인하는 응답
- **RST (Reset)**: 연결을 재설정할 때 사용
- **PSH (Push)**: 빠른 응답이 필요한 데이터를 응용 계층으로 즉시 전송할 때 사용
- **URG (Urgent)**: 우선순위가 높은 데이터를 전송할 때 사용

<br/><br/>

### ☑️ 3-way 핸드셰이킹
: 데이터를 본격적으로 주고받기 전에 상대방 컴퓨터와 세션을 수립하는 과정
- 데이터의 정확한 전달을 위해 필요한 절차
- 이 과정에서 데이터의 송신자와 수신자 모두 데이터를 주고받을 준비가 되었음을 보장한다.
- 송신부와 수신부 간에 번갈아 3번 요청과 응답을 해서 연결을 확인한 후에 본격적으로 데이터 통신을 하게 된다. 

<br/>

#### ⏩ 3-way 핸드셰이킹 과정
https://velog.velcdn.com/images/dltmdrl1244/post/dba37a03-4a62-40f0-b893-4e96bd42cb89/image.png


1단계: SYN 메시지 전송
   - 송신부 <br/>
: 수신부에게 연결을 요청하는 메시지(SYN)를 보낸다.  
     - 이 메시지에는 임의의 숫자 N이 포함된다.
   - 상태: 송신부는 SYN_SENT 상태가 되어, 수신부의 응답을 기다린다.
<br/>

2단계: SYN-ACK 메시지 전송
   - 수신부 <br/>
: 송신부로부터 SYN 메시지를 받으면 연결 요청을 수락한다.
   - 응답 <br/>
: 수신부는 ACK 메시지를 보낸다.
     - 여기에는 N+1(송신부가 보낸 숫자 N에 1을 더한 값)이 포함된다. <br/>
이것은 송신부의 메시지를 잘 받았다는 신호이다.
   - 추가 요청 <br/>
: 수신부도 연결을 확인하기 위해 자신의 임의의 숫자 M을 포함한 SYN 메시지를 보낸다.
   - 상태: 수신부는 SYN_RECEIVED 상태가 되어, 송신부의 최종 응답을 기다린다.
<br/>

3단계: ACK 메시지 전송
   - 송신부 <br/>
: 수신부로부터 SYN-ACK 메시지를 받으면, 연결이 거의 완료된 것이다.
   - 응답 <br/>
: 송신부는 수신부에게 M+1(수신부가 보낸 숫자 M에 1을 더한 값)을 포함한 ACK 메시지를 보낸다.
   - 상태: 이 단계가 완료되면 송신부와 수신부 모두 established 상태가 되어, 안전한 데이터 전송이 가능해진다.

<br/><br/>

### ☑️ 4-way 핸드셰이킹
: TCP 연결을 해제할 때 이뤄지는 과정
- 연결을 해제할 때는 요청과 응답을 총 4번 주고받게 된다.

<br/>

#### ⏩ 4-way 핸드셰이킹 과정
https://velog.velcdn.com/images/dltmdrl1244/post/34e2dfe7-6093-4558-90fa-429043505a82/image.png

1단계: 송신부의 FIN 메시지 전송 (FIN_WAIT1 상태)
   - 송신부 <br/>
: 수신부에게 연결 종료를 요청하는 FIN 메시지를 보낸다.
이 메시지는 송신부가 더 이상 데이터를 전송하지 않겠다는 신호이다.
- 상태: 송신부는 FIN_WAIT1 상태가 되어, 수신부의 응답을 기다린다.
<br/>

2단계: 수신부의 ACK 메시지 전송 (CLOSE_WAIT 상태)
- 수신부: 송신부의 FIN 메시지를 받으면, 이를 확인하고 ACK 메시지로 응답한다. 
이 메시지에는 송신부의 FIN 메시지를 수신했음을 알리는 신호가 포함된다.
- 추가 작업 <br/>
: 수신부는 연결 종료를 위한 작업(예: 애플리케이션 종료 등)을 수행한다.
- 상태: 수신부는 CLOSE_WAIT 상태가 되며, 송신부는 수신부의 ACK 메시지를 받고 FIN_WAIT2 상태로 변환된다.
<br/>

3단계: 수신부의 FIN 메시지 전송 (LAST_ACK 상태)
- 수신부 <br/>
: 연결 종료 작업이 완료되면 송신부에게 FIN 메시지를 보내 연결 종료를 요청한다.
- 상태: 수신부는 LAST_ACK 상태로 변환되며, 송신부의 최종 ACK 메시지를 기다린다.
<br/>

4단계: 송신부의 ACK 메시지 전송 및 TIME_WAIT 상태 (CLOSED 상태)
- 송신부 <br/>
: 수신부의 FIN 메시지를 받으면, 이에 대한 ACK 메시지를 보낸다.
- 수신부 <br/>
: 송신부의 ACK 메시지를 받으면 CLOSED 상태로 변환된다.
- 상태: 송신부는 TIME_WAIT 상태로 전환되며, 일정 시간 동안 이 상태를 유지한다. <br/>
이 시간 동안 패킷 유실이나 ACK 메시지 손실에 대비하여 연결이 완전히 종료될 때까지 기다린다. <br/>
이후 송신부는 CLOSED 상태가 됩니다.


<br/><br/>
<br/>

## ✅ TCP 제어 방법
: TCP의 데이터 신뢰성을 보장하기 위한 제어 방법

<br/>

### ☑️ 흐름 제어(flow control)
: 데이터 송신부와 수신부에서 데이터 처리 속도의 차이 때문에 생기는 데이터 손실을 방지하는 방법

<br/>

#### ⏩ 흐름 제어 방식

1. 정지-대기(stop-wait) <br/>
: 송신부에서 데이터를 보낸 후 수신부로부터 ACK 메시지를 받을 때까지 다음 데이터를 보내지 않고 기다리는 방식
   - 송신부에서 패킷을 보내고 일정 시간 동안 수신부로부터 ACK 메시지를 받지 못하면 패킷을 재전송한다. 
   - 장점: 간단하다.
   - 단점: 이전 메시지에 대한 응답을 받아야만 다음 메시지를 보낼 수 있어서 시간 면에서 비효율적이다.

https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FrSK5R%2Fbtq6Qug3mn3%2FaKQ3kMYn6wlE2oPaGy8wDk%2Fimg.png

<br/>

2. 슬라이딩 윈도우(sliding window) <br/>
: 송신부에서 데이터의 수신 여부(ACK)를 확인하지 않고, 수신부에서 설정한 윈도우 크기만큼 데이터를 연속적으로 보낼 수 있게 해서 데이터 흐름을 동적으로 제어하는 방식
   - 윈도우 크기는 응답받지 않고도 보낼 수 있는 데이터의 최대 개수를 의미하며, 3–way 핸드셰이킹 과정에서 정해진다.

https://blog.skby.net/wp-content/uploads/2018/11/2-47.png

- 윈도우 크기 설정 <br/>
   - 데이터 송신자는 송신 윈도우 크기 𝑁을 설정한다. 
   - 이 크기는 동시에 송신자가 보낼 수 있는 데이터의 양을 의미한다. 
   - ex) N=4라면, 송신자는 최대 4개의 데이터 블록을 한 번에 보낼 수 있다.

- 데이터 송신 <br/>
   - 송신자는 초기 상태에서 윈도우 크기만큼의 데이터(ex. 데이터 1부터 데이터 4까지)를 송신한다. 
   - 이 데이터는 수신자로부터 ACK(승인 응답) 메시지를 기다리면서 전송된다.

- ACK 메시지 수신 <br/>
   - 수신자는 데이터 블록을 수신하고, 올바르게 수신된 데이터에 대해 ACK 메시지를 송신자에게 보낸다. <br/>
(ACK 메시지: 특정 데이터까지 올바르게 수신했음을 알리는 메시지)
   - ex) 데이터 1부터 데이터 4까지 수신한 후, 데이터 1에 대한 ACK를 송신한다.

- 윈도우 이동 <br/>
   - 송신자는 데이터 1에 대한 ACK 메시지를 받으면, 윈도우를 이동시켜 다음 데이터 블록을 보낼 수 있다. 
   - 이런 경우, 새로운 윈도우는 데이터 5부터 데이터 8까지, 데이터 5부터 다음 4개 블록을 송신할 수 있다. 

- 슬라이딩 윈도우 <br/>
   - 이렇게 ACK 메시지를 수신할 때마다 송신자는 윈도우를 이동시키며 다음 데이터를 전송한다. 
   - 윈도우가 이동하는 방식으로 송신자는 데이터 흐름을 조절하며, 데이터가 성공적으로 수신되었는지 확인하고 새로운 데이터 블록을 전송할 수 있다.


<br/><br/>

### ☑️ 혼잡 제어(congestion control)
: 송신부의 데이터 전달 속도와 네트워크 속도 차이로 데이터 손실이 발생하는 것을 방지하기 위한 방법
- 혼잡(네트워크에 패킷 수가 과도하게 증가하는 증상)이 발생해 네트워크에 패킷이 쌓이면서 일정 시간 응답을 받지 못하면, 송신부에서는 메시지 전송에 실패했다고 판단해 수신부에 패킷을 재전송한다. 
- 이것은 혼잡을 가중해 악순환을 야기하기 때문에 TCP는 혼잡 윈도우의 크기를 조절해 혼잡에 대응한다. 

<br/>

#### ⏩ 혼잡 제어 방식

1. AIMD(Additive Increase Multiplicative Decrease) <br/>
: 네트워크의 혼잡 상태를 관리하고 데이터 전송 속도를 효율적으로 조절하는 알고리즘

   - 특징
     - 합 증가 (Additive Increase) <br/>
       - 데이터를 전달할 때 합 증가(additive increase) 방식으로 혼잡 윈도우의 크기를 점진적으로 증가시킨다. <br/> ex) 매 전송마다 윈도우 크기를 일정량씩 추가하여 혼잡 윈도우를 키워갑니다.

     - 곱 감소 (Multiplicative Decrease) <br/>
       - 데이터 손실이 발생하면, 혼잡 윈도우의 크기를 곱 감소(multiplicative decrease) 방식을 적용해 1/2배와 같이 배수 단위로 줄인다. <br/>
    ex) 데이터 손실이 발생하면 윈도우 크기를 1/2배로 줄인다.

   - 장점
     - 공평한 대역폭 사용 <br/>
       - AIMD 방식은 시간이 지남에 따라 네트워크 대역폭을 여러 송신부 간에 공평하게 사용할 수 있도록 조정한다.

   - 단점
     - 느린 대역폭 확장 <br/>
       - 데이터 유실이 발생하면 윈도우 크기 감소폭이 크기 때문에, 네트워크 대역폭을 넓게 사용하기까지 시간이 오래 걸린다.

https://velog.velcdn.com/images%2Fkcwthing1210%2Fpost%2F530f52c3-b300-4e57-8df1-e730f4f139ba%2Fimage.png

<br/>

2. 느린 시작(slow start) <br/>
: 윈도우 크기가 1인 상태에서 시작해 ACK 메시지를 수신할 때마다 윈도우 크기를 1씩 늘려나가다가 혼잡이 발생하면 윈도우 크기를 1로 확 줄이는 방식

    - 작동 방식
      - 초기 상태
        - 윈도우 크기는 1로 설정된 상태에서 시작한다.

      - 윈도우 크기 증가
        - 각 ACK 메시지를 수신할 때마다 윈도우 크기를 지수 함수 형태로 1씩 증가시킨다. <br/>
ex) 패킷 1개에 대한 ACK를 받으면 다음에는 패킷 2개를 전송하고, 2개에 대한 ACK를 받으면 패킷 4개를 전송한다 (1 → 2 → 4 → 8 등)

      - 혼잡 발생 시 조정
        - 네트워크 혼잡이 발생하면 윈도우 크기를 1로 급격히 줄인다. <br/> ➡︎ 데이터 전송을 줄여 네트워크 혼잡을 완화

   - 특징
     - 점진적 증가
       - 패킷 전송 초기에는 윈도우 크기를 1개부터 시작하여 점진적으로 증가시킨다. <br/>
➡︎ AIMD 방식에서 초기에 전송 가능한 패킷 수가 적다는 단점을 보완 <br/>
➡︎ 네트워크의 안정성을 유지

     - 지수 함수 증가
       - 윈도우 크기가 ACK 수신에 따라 지수적으로 증가하므로 초기에는 전송 가능한 패킷 수가 적지만, 혼잡이 없을 경우 빠르게 증가한다.
   - 장점
     - AIMD 방식의 초기 전송 수가 적다는 단점을 보완한다.
     - 네트워크 대역폭을 효율적으로 활용할 수 있다.

<br/>

3. 혼잡 회피(congestion avoidance) <br/>
: 윈도우 크기가 지수 함수 형태로 증가하다가 혼잡이 발생하는 것을 방지하기 위해 윈도우 크기에 대한 임계점(threshold)을 정하는 방식

   - 작동 방식
     - 임계점 설정
       - 윈도우 크기가 지수 함수 형태로 증가하다가 사전에 설정된 임계점에 도달하면, 혼잡 회피 단계로 전환됩니다. 이 임계점은 네트워크가 처리할 수 있는 최대 대역폭을 고려하여 설정됩니다.
     - 선형적 증가
       - 임계점에 도달하면 윈도우 크기를 지수 함수 형태가 아닌 선형적으로 증가시킵니다. 이 경우, ACK 메시지를 수신할 때마다 윈도우 크기를 일정량(예: 1 MSS)씩 증가시킵니다.
예를 들어, 윈도우 크기가 임계점 16에 도달한 후에는 매 RTT마다 윈도우 크기를 1씩 추가하여 17, 18, 19, ...로 증가시킵니다.
     - 타임아웃 발생 시 조정
       - 만약 타임아웃이 발생하면, 이는 네트워크 혼잡이 발생했음을 의미합니다. 이 경우, 윈도우 크기를 현재 크기의 절반으로 줄이고, 이 절반 값을 새로운 임계점으로 설정합니다. 이후 윈도우 크기를 초깃값(보통 1)으로 변경하여 느린 시작 단계로 돌아갑니다. 이로 인해 혼잡 상태를 완화하고 네트워크를 안정화합니다.



정리된 혼잡 회피 방식

임계점 도달: 윈도우 크기가 지수 함수 형태로 증가하다가 설정된 임계점에 도달하면, 윈도우 크기 증가 방식을 선형적으로 변경합니다.

선형적 증가: ACK 메시지 수신 시 윈도우 크기를 일정량씩 증가시킵니다.

타임아웃 처리: 타임아웃 발생 시 윈도우 크기를 절반으로 줄이고, 새로운 임계점을 설정한 후 초깃값으로 돌아가서 다시 느린 시작 단계로 진입합니다.


혼잡 회피는 네트워크의 대역폭을 효율적으로 활용하면서 혼잡을 방지하고 안정적인 데이터 전송을 유지하는 데 중요한 역할을 합니다.



<br/>

4. 빠른 회복(fast recovery)
: 
혼잡이 발생하면 혼잡 윈도우 크기를 절반으로 줄인 후 선형적으로 증가하는 방식이다. 
즉, 혼잡이 처음 발생하면 AIMD 방식으로 동작한다.

<br/>

5. 빠른 재전송(fast retransmit)
: 
Duplicate ACK가 3번 발생하면(3 Duplicate ACK) 해당 시점의 윈도우 크기를 1/2로 줄인다. 
그 뒤로 ACK 메시지를 받으면 다시 윈도우 크기를 키우는 방식이다. 
Duplicate ACK는 패킷이 순서대로 도착하지 않아서 받아야 할 차례의 패킷을 ACK 메시지와 함께 요청하는 것을 뜻한다. 
즉, Duplicate ACK가 3번 발생하면 혼잡이 발생했다고 판단해 윈도우 크기를 조정한다.

예를 들어, 송신부에서 패킷 0부터 5까지 보냈지만, 수신부에는 패킷 2가 오지 않았다. 
수신부에서는 패킷 3, 4, 5에 대해 패킷 2를 보내라고 응답한다. 
해당 응답이 3번 반복되면 송신측에서는 패킷 2를 재전송한다. 
이때 윈도우 크기는 1/2로 줄어든다.



<br/><br/>

#### 📢 TCP 혼합 제어 정책





<br/><br/>

### ☑️ 오류 제어

<br/>

#### ⏩ 
















<br/><br/>
<br/>

## ✅ UDP

<br/>

### ☑️ 




<br/><br/>
<br/>

## ✅ UDP의 오류 검출

<br/>

### ☑️ 




<br/>

#### ⏩ 




<br/><br/>
