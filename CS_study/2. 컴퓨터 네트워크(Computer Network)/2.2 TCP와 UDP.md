
# 📌 TCP와 UDP

<br/>

## 목차
1. [TCP (Transmission Control Protocol)](#-tcp-transmission-control-protocol)
2. [TCP 핸드셰이킹(handshaking)](#-tcp-핸드셰이킹handshaking)
3. [TCP 제어 방법](#-tcp-제어-방법)
4. [UDP (User Datagram Protocol, 사용자 데이터그램 프로토콜)](#-udp-user-datagram-protocol-사용자-데이터그램-프로토콜)
5. [UDP의 오류 검출](#-udp의-오류-검출)

<br/><br/>

## ✅ TCP (Transmission Control Protocol)
: **전송 계층에 해당하는 네트워크 프로토콜**
- 연결형 서비스를 지원하고, 데이터의 신뢰성을 보장한다.
- 송신부와 수신부의 연결을 확인하는 연결형 서비스다.
- 패킷 교환 방식은 패킷이 전달되는 회선이 정해져 있는 가상 회선 방식이다.
- 패킷의 전송 순서가 보장된다.
- 패킷의 수신 여부를 확인한다.
- 송신부와 수신부는 1:1 통신을 한다.
- 데이터 손실이 없음을 보장하므로 신뢰성이 높다⬆️
- 데이터의 송수신 속도가 느리다⬇️

<br/>

### ☑️ 패킷(packit) 교환 방식
: **가장 많이 사용하는 데이터 통신 방식**

- **가상 회선 방식** <br/>
: **데이터를 주고받기 전에 패킷을 전송할 경로인 가상 회선을 설정**해서 **모든 패킷을 같은 경로로 전송**하는 방식

![](https://woovictory.github.io/img/virtual_circut_packet.png) <br/>
출처: [가상 회선 방식](https://woovictory.github.io/img/virtual_circut_packet.png)

<br/>

- **데이터그램 방식** <br/>
: **패킷마다 최적의 경로로 전송**되는 방식
  - 송신부에서 보낸 패킷의 순서와 수신부에 도착하는 **패킷의 순서가 다를 수 있다.**

![](https://woovictory.github.io/img/datagram_packet.png) <br/>
출처: [데이터그램 방식](https://woovictory.github.io/img/datagram_packet.png)

<br/>

✨ [패킷(packet)](https://github.com/kwonboryong/CS_study/blob/main/CS_study/2.%20%EC%BB%B4%ED%93%A8%ED%84%B0%20%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC(Computer%20Network)/2.1%20%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%20%EA%B3%84%EC%B8%B5.md#-%EA%B8%B0%ED%83%80-%EC%9A%A9%EC%96%B4)
: 네트워크에서 주고받는 데이터를 작게 분할한 단위

<br/><br/>
<br/>
  
## ✅ TCP 핸드셰이킹(handshaking)
- TCP에서는 연결형 서비스를 지원하기 위해 **송신부와 수신부 간의 연결을 설정하고 종료하는 과정**을 거친다. 
- 연결 시작 👉 3 –way 핸드셰이킹 사용
- 연결 종료 👉 4 –way 핸드셰이킹 사용

<br/>

#### ⏩ 플래그(flag) 값
: 핸드셰이킹 과정에서는 **송신부와 수신부 간 연결 관리를 위해 플래그(flag) 값을 주고 받는다.** <br/>

- **SYN (Synchronization)**: 송신자가 **연결 요청**을 보낼 때 사용
- **FIN (Finish)**: 송신자가 **연결 종료**를 요청할 때 사용
- **ACK (Acknowledgment)**: 수신자가 **데이터가 성공적으로 수신되었음(FIN 패킷 수신)을 확인**하는 응답
- **RST (Reset)**: **연결을 재설정**할 때 사용
- **PSH (Push)**: **빠른 응답이 필요한 데이터를 응용 계층으로 즉시 전송**할 때 사용
- **URG (Urgent)**: **우선순위가 높은 데이터를 전송**할 때 사용

<br/><br/>

### ☑️ 3-way 핸드셰이킹
: **데이터를 본격적으로 주고받기 전에 상대방 컴퓨터와 세션을 수립하는 과정**
- **데이터의 정확한 전달을 위해 필요한 절차**
- 이 과정에서 데이터의 송신자와 수신자 모두 데이터를 주고받을 준비가 되었음을 보장한다.
- **송신부와 수신부 간에 번갈아 3번 요청과 응답을 해서 연결을 확인**한 후에 본격적으로 데이터 통신을 하게 된다. 

<br/>

#### ⏩ 3-way 핸드셰이킹 과정

![](https://velog.velcdn.com/images/dltmdrl1244/post/dba37a03-4a62-40f0-b893-4e96bd42cb89/image.png) <br/>
출처: [3-way 핸드셰이킹 과정](https://velog.velcdn.com/images/dltmdrl1244/post/dba37a03-4a62-40f0-b893-4e96bd42cb89/image.png)

<br/>

**1단계: SYN 메시지 전송**
   - **송신부** <br/>
: **수신부에게 연결을 요청하는 메시지(SYN)를 보낸다.**  
     - 이 메시지에는 임의의 숫자 N이 포함된다.
   - **상태**: **송신부는 SYN_SENT 상태**가 되어, 수신부의 응답을 기다린다.
<br/>

**2단계: SYN-ACK 메시지 전송**
   - **수신부** <br/>
: **송신부로부터 SYN 메시지를 받으면 연결 요청을 수락**한다.
   - **응답** <br/>
: 수신부는 ACK 메시지를 보낸다.
     - 여기에는 **N+1(송신부가 보낸 숫자 N에 1을 더한 값)**이 포함된다. <br/>
이것은 송신부의 메시지를 잘 받았다는 신호이다.
   - **추가 요청** <br/>
: 수신부도 연결을 확인하기 위해 자신의 임의의 숫자 M을 포함한 SYN 메시지를 보낸다.
   - **상태**: **수신부는 SYN_RECEIVED 상태**가 되어, 송신부의 최종 응답을 기다린다.
<br/>

**3단계: ACK 메시지 전송**
   - **송신부** <br/>
: **수신부로부터 SYN-ACK 메시지를 받으면, 연결이 거의 완료**된 것이다.
   - **응답** <br/>
: 송신부는 수신부에게 **M+1(수신부가 보낸 숫자 M에 1을 더한 값)**을 포함한 ACK 메시지를 보낸다.
   - **상태**: 이 단계가 완료되면 **송신부와 수신부 모두 established 상태**가 되어, 안전한 데이터 전송이 가능해진다.

<br/><br/>

### ☑️ 4-way 핸드셰이킹
: **TCP 연결을 해제**할 때 이뤄지는 과정
- 연결을 해제할 때는 **요청과 응답을 총 4번** 주고받게 된다.

<br/>

#### ⏩ 4-way 핸드셰이킹 과정

![](https://velog.velcdn.com/images/dltmdrl1244/post/34e2dfe7-6093-4558-90fa-429043505a82/image.png) <br/>
출처: [4-way 핸드셰이킹 과정](https://velog.velcdn.com/images/dltmdrl1244/post/34e2dfe7-6093-4558-90fa-429043505a82/image.png)

<br/>

**1단계: 송신부의 FIN 메시지 전송 (FIN_WAIT1 상태)**
   - **송신부** <br/>
: **수신부에게 연결 종료를 요청하는 FIN 메시지**를 보낸다. <br/>
이 메시지는 송신부가 더 이상 데이터를 전송하지 않겠다는 신호이다.
- **상태**: **송신부는 FIN_WAIT1 상태**가 되어, 수신부의 응답을 기다린다.
<br/>

**2단계: 수신부의 ACK 메시지 전송 (CLOSE_WAIT 상태)**
- **수신부** <br/>
: **송신부의 FIN 메시지를 받으면, 이를 확인하고 ACK 메시지로 응답**한다. 
이 메시지에는 송신부의 FIN 메시지를 수신했음을 알리는 신호가 포함된다.
- **추가 작업** <br/>
: 수신부는 연결 종료를 위한 작업(ex. 애플리케이션 종료 등)을 수행한다.
- **상태**: **수신부는 CLOSE_WAIT 상태**가 되며, **송신부는** 수신부의 ACK 메시지를 받고 **FIN_WAIT2 상태**로 변환된다.
<br/>

**3단계: 수신부의 FIN 메시지 전송 (LAST_ACK 상태)**
- **수신부** <br/>
: **연결 종료 작업이 완료되면 송신부에게 FIN 메시지를 보내 연결 종료를 요청**한다.
- **상태**: **수신부는 LAST_ACK 상태**로 변환되며, 송신부의 최종 ACK 메시지를 기다린다.
<br/>

**4단계: 송신부의 ACK 메시지 전송 및 TIME_WAIT 상태 (CLOSED 상태)**
- **송신부** <br/>
: **수신부의 FIN 메시지를 받으면, 이에 대한 ACK 메시지를 보낸다.**
- **수신부** <br/>
: 송신부의 ACK 메시지를 받으면 CLOSED 상태로 변환된다.
- **상태**: **송신부는 TIME_WAIT 상태**로 전환되며, 일정 시간 동안 이 상태를 유지한다. <br/>
이 시간 동안 패킷 유실이나 ACK 메시지 손실에 대비하여 연결이 완전히 종료될 때까지 기다린다. <br/>
이후 송신부는 CLOSED 상태가 된다.

<br/><br/>
<br/>

## ✅ TCP 제어 방법
: **TCP의 데이터 신뢰성을 보장하기 위한 제어 방법**

<br/>

### ☑️ 흐름 제어(flow control)
: 데이터 송신부와 수신부에서 **데이터 처리 속도의 차이 때문에 생기는 데이터 손실을 방지하는 방법**

<br/>

#### ⏩ 흐름 제어 방식

1. **정지-대기(stop-wait)** <br/>
: **송신부에서 데이터를 보낸 후 수신부로부터 ACK 메시지를 받을 때까지 다음 데이터를 보내지 않고 기다리는 방식**
   - 송신부에서 패킷을 보내고 일정 시간 동안 수신부로부터 ACK 메시지를 받지 못하면 패킷을 재전송한다. 
   - 장점: 간단하다.
   - 단점: 이전 메시지에 대한 응답을 받아야만 다음 메시지를 보낼 수 있어서 시간 면에서 비효율적이다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FrSK5R%2Fbtq6Qug3mn3%2FaKQ3kMYn6wlE2oPaGy8wDk%2Fimg.png) <br/>
출처: [정지-대기(stop-wait)](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FrSK5R%2Fbtq6Qug3mn3%2FaKQ3kMYn6wlE2oPaGy8wDk%2Fimg.png)

<br/><br/>

2. **슬라이딩 윈도우(sliding window)** <br/>
: 송신부에서 데이터의 수신 여부(ACK)를 확인하지 않고, **수신부에서 설정한 윈도우 크기만큼 데이터를 연속적으로 보낼 수 있게 해서 데이터 흐름을 동적으로 제어**하는 방식
   - 윈도우 크기: 응답받지 않고도 보낼 수 있는 데이터의 최대 개수를 의미
     - 3–way 핸드셰이킹 과정에서 정해진다.

![](https://blog.skby.net/wp-content/uploads/2018/11/2-47.png) <br/>
출처: [슬라이딩 윈도우(sliding window)](https://blog.skby.net/wp-content/uploads/2018/11/2-47.png)

<br/>

- **윈도우 크기 설정** <br/>
   - **데이터 송신자는 송신 윈도우 크기 𝑁을 설정한다.**
   - 이 크기는 **동시에 송신자가 보낼 수 있는 데이터의 양**을 의미한다. 
   - ex) N=4라면, 송신자는 최대 4개의 데이터 블록을 한 번에 보낼 수 있다.

- **데이터 송신** <br/>
   - **송신자는 초기 상태에서 윈도우 크기만큼의 데이터(ex. 데이터 1부터 데이터 4까지)를 송신한다.** 
   - 이 데이터는 수신자로부터 ACK(승인 응답) 메시지를 기다리면서 전송된다.

- **ACK 메시지 수신** <br/>
   - **수신자는 데이터 블록을 수신**하고, **올바르게 수신된 데이터에 대해 ACK 메시지를 송신자에게 보낸다.** <br/>
(ACK 메시지: 특정 데이터까지 올바르게 수신했음을 알리는 메시지)
   - ex) 데이터 1부터 데이터 4까지 수신한 후, 데이터 1에 대한 ACK를 송신한다.

- **윈도우 이동** <br/>
   - **송신자는 데이터 1에 대한 ACK 메시지를 받으면, 윈도우를 이동시켜 다음 데이터 블록을 보낼 수 있다.**
   - 이런 경우, 새로운 윈도우는 데이터 5부터 데이터 8까지, 데이터 5부터 다음 4개 블록을 송신할 수 있다. 

- **슬라이딩 윈도우** <br/>
   - **ACK 메시지를 수신할 때마다 송신자는 윈도우를 이동시키며 다음 데이터를 전송한다.**
   - **윈도우가 이동하는 방식으로 송신자는 데이터 흐름을 조절**하며, 데이터가 성공적으로 수신되었는지 확인하고 새로운 데이터 블록을 전송할 수 있다.

<br/><br/>

### ☑️ 혼잡 제어(congestion control)
: **송신부의 데이터 전달 속도와 네트워크 속도 차이로 데이터 손실이 발생하는 것을 방지**하기 위한 방법
- 혼잡(네트워크에 패킷 수가 과도하게 증가하는 증상)이 발생하여 네트워크에 패킷이 쌓이면서 일정 시간 응답을 받지 못하면, **송신부에서는 메시지 전송에 실패했다고 판단해 수신부에 패킷을 재전송한다.**
- 이것은 혼잡을 가중해 악순환을 야기하기 때문에 **TCP는 혼잡 윈도우의 크기를 조절해 혼잡에 대응한다.**

<br/>

#### ⏩ 혼잡 제어 방식

1. **AIMD(Additive Increase Multiplicative Decrease)** <br/>
: **네트워크의 혼잡 상태를 관리**하고 데**이터 전송 속도를 효율적으로 조절하는 알고리즘**

   - **특징**
     - **증가 (Additive Increase)** <br/>
       - **데이터를 전달할 때 합 증가 방식으로 혼잡 윈도우의 크기를 점진적으로 증가시킨다.** <br/> 
       ex) 매 전송마다 윈도우 크기를 일정량씩 추가하여 혼잡 윈도우를 키워갑니다.

     - **곱 감소 (Multiplicative Decrease)** <br/>
       - **데이터 손실이 발생하면, 혼잡 윈도우의 크기를 곱 감소 방식을 적용해 1/2배와 같이 배수 단위로 줄인다.** <br/>
    ex) 데이터 손실이 발생하면 윈도우 크기를 1/2배로 줄인다.

   - **장점**
     - **공평한 대역폭 사용** <br/>
       - AIMD 방식은 시간이 지남에 따라 **네트워크 대역폭을 여러 송신부 간에 공평하게 사용할 수 있도록 조정**한다.

   - **단점**
     - **느린 대역폭 확장** <br/>
       - **데이터 유실이 발생하면 윈도우 크기 감소폭이 크기 때문에, 네트워크 대역폭을 넓게 사용하기까지 시간이 오래 걸린다.**

![](https://velog.velcdn.com/images%2Fkcwthing1210%2Fpost%2F530f52c3-b300-4e57-8df1-e730f4f139ba%2Fimage.png) <br/>
출처: [AIMD](https://velog.velcdn.com/images%2Fkcwthing1210%2Fpost%2F530f52c3-b300-4e57-8df1-e730f4f139ba%2Fimage.png)

<br/>

2. **느린 시작(slow start)** <br/>
: 윈도우 크기가 1인 상태에서 시작하여 **ACK 메시지를 수신할 때마다 윈도우 크기를 1씩 늘려나가다가 혼잡이 발생하면 윈도우 크기를 1로 확 줄이는 방식**

    - **작동 방식**
      - **초기 상태**
        - 윈도우 크기는 1로 설정된 상태에서 시작한다.

      - **윈도우 크기 증가**
        - 각 ACK 메시지를 수신할 때마다 윈도우 크기를 지수 함수 형태로 1씩 증가시킨다. <br/>
ex) 패킷 1개에 대한 ACK를 받으면 다음에는 패킷 2개를 전송하고, 2개에 대한 ACK를 받으면 패킷 4개를 전송한다 (1 → 2 → 4 → 8 등)

      - **혼잡 발생 시 조정**
        - 네트워크 혼잡이 발생하면 윈도우 크기를 1로 급격히 줄인다. <br/> ➡︎ 데이터 전송을 줄여 네트워크 혼잡을 완화

   - **특징**
     - **점진적 증가**
       - 패킷 전송 초기에는 윈도우 크기를 1개부터 시작하여 점진적으로 증가시킨다. <br/>
➡︎ AIMD 방식에서 초기에 전송 가능한 패킷 수가 적다는 단점을 보완 <br/>
➡︎ 네트워크의 안정성을 유지

     - **지수 함수 증가**
       - 윈도우 크기가 ACK 수신에 따라 지수적으로 증가하므로 초기에는 전송 가능한 패킷 수가 적지만, 혼잡이 없을 경우 빠르게 증가한다.
   - **장점**
     - AIMD 방식의 초기 전송 수가 적다는 단점을 보완한다.
     - 네트워크 대역폭을 효율적으로 활용할 수 있다.

<br/>

3. **혼잡 회피(congestion avoidance)** <br/>
: **윈도우 크기가 지수 함수 형태로 증가하다가 혼잡이 발생하는 것을 방지하기 위해 윈도우 크기에 대한 임계점(threshold)을 정하는 방식**

   - **작동 방식**
     - **임계점 설정**
       - **윈도우 크기가 지수 함수 형태로 증가하다가 사전에 설정된 임계점에 도달하면, 혼잡 회피 단계로 전환**된다.
       - 이 임계점은 네트워크가 처리할 수 있는 최대 대역폭을 고려하여 설정된다.

     - **선형적 증가**
       - **윈도우 크기가 지수 함수 형태로 증가하다가 설정된 임계점에 도달하면, 윈도우 크기 증가 방식을 지수 선형적으로 증가시킨다.**
       - 이 경우, ACK 메시지를 수신할 때마다 윈도우 크기를 일정량(ex. 1 MSS)씩 증가시킨다.  <br/>
ex) 윈도우 크기가 임계점 16에 도달한 후에는 매 RTT마다 윈도우 크기를 1씩 추가하여 17, 18, 19, ...로 증가시킨다.

     - **타임아웃 발생 시 조정**
       - 만약 타임아웃이 발생하면, 이는 네트워크 혼잡이 발생했음을 의미한다.
       - 타임아웃 발생 시 윈도우 크기를 현재 크기의 절반으로 줄이고, 이 절반 값을 새로운 임계점으로 설정한다.
       - 이후 윈도우 크기를 초깃값(1)으로 변경하여 느린 시작 단계로 돌아간다. <br/>
➡︎ 혼잡 상태를 완화하고 네트워크를 안정화합니다.

<br/>

4. **빠른 회복(fast recovery)** <br/>
: **혼잡이 발생하면 혼잡 윈도우 크기를 절반으로 줄인 후 선형적으로 증가**하는 방식
   - 혼잡이 처음 발생하면 AIMD 방식으로 동작한다.

<br/>

5. **빠른 재전송(fast retransmit)** <br/>
: **Duplicate ACK가 3번 발생하면(3 Duplicate ACK) 해당 시점의 윈도우 크기를 1/2로 줄이고, ACK 메시지를 받으면 다시 윈도우 크기를 키우는 방식**
   - Duplicate ACK가 3번 발생하면 혼잡이 발생했다고 판단해 윈도우 크기를 조정한다.
     - **Duplicate ACK** <br/>
: 패킷이 순서대로 도착하지 않아서 받아야 할 차례의 패킷을 ACK 메시지와 함께 요청하는 것

   - ex) 송신부에서 패킷 0부터 5까지 보냈지만, 수신부에는 패킷 2가 오지 않았다. <br/>
➡︎ 수신부에서는 패킷 3, 4, 5에 대해 패킷 2를 보내라고 응답한다. <br/>
➡︎ 해당 응답이 3번 반복되면 송신측에서는 패킷 2를 재전송한다. <br/>
➡︎ 이때 윈도우 크기는 1/2로 줄어든다.


<br/><br/>

### 📢 TCP 혼합 제어 정책
TCP는 혼잡 제어 방식을 여럿 혼합해 혼합 제어 정책을 사용한다. 
혼잡이 발생하면 윈도우 크기를 줄이거나 유지해서 혼잡을 회피하려고 한다. 

1. **TCP Tahoe(타호)** <br/>
: **"느린 시작(Slow Start)"으로 시작하여 혼잡 윈도우(Congestion Window, CWND)를 지수적으로 증가시킨다. 임계점(Threshold, ssthresh)에 도달하면 선형적으로 혼잡 윈도우가 증가한다.**

   - **혼잡 발생 시 대처**
     1. CWND를 1 MSS(Maximum Segment Size)로 감소시킨다.
     2. 다시 Slow Start부터 시작하여 CWND를 재성장 시킨다.
     3. 새로운 임계치(ssthresh)는 패킷 유실이 발생한 시점의 CWND의 절반으로 초기화 된다.

   - **단점**
     - CWND를 항상 1 MSS로 초기화하기 때문에, 혼잡이 발생한 후 원래의 전송 속도로 복구하는 데 시간이 많이 소요된다.

<br/>

2. **TCP Reno(레노)** <br/>
: TCP Tahoe와 동일하게 **초반에는 느린 시작을 사용하여 CWND를 증가시키지만, 3 Duplicate ACK와 타임아웃을 구분하여 대응한다.**
   - **혼잡 발생 시 대처**
     - **타임아웃이 발생 시**
       1. 혼잡 윈도우(CWND) 크기를 절반으로 줄이고, 줄인 혼잡 윈도우 크기를 ssthresh 값으로 설정한다. 
       2. 이후 Slow Start로 전송을 재개한다.

     - **3중 중복 ACK(Triple Duplicate ACK) 발생 시** <br/>
       - ssthresh를 CWND의 절반으로 설정한 후, CWND를 ssthresh 값으로 감소시키고 전송을 이어간다. <br/> 이것은 "빠른 회복(Fast Recovery)" 방식으로, CWND를 1 MSS로 초기화하지 않고 전송 속도를 빠르게 복구할 수 있다.

     - **Threshold 설정** <br/>
       - ssthresh 값은 패킷 유실이 발생한 시점의 CWND 크기의 절반으로 설정되며, 이후 CWND는 ssthresh에 도달할 때까지 선형적으로 증가한다.

<br/>

* 비교 및 개선점 <br/>
  - **TCP Tahoe** <br/> ➡︎ 패킷 유실 시 항상 CWND를 1 MSS로 초기화하여 다시 Slow Start부터 시작한다. 
이로 인해 전송 속도를 복구하는 데 시간이 오래 걸린다.

  - **TCP Reno** <br/> ➡︎ 패킷 유실의 원인에 따라 다르게 대응하여, 전송 속도의 회복을 더 빠르게 할 수 있도록 개선되었다. 특히, 3중 중복 ACK의 경우 CWND를 1 MSS로 초기화하지 않고 ssthresh 값으로 설정하여 빠르게 전송을 재개할 수 있다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FZY3Mb%2FbtrjjbWBRgU%2FUO4FMQlrf7TIlPryutLYT0%2Fimg.png) <br/>
출처: [TCP Tahoe & TCP Reno](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FZY3Mb%2FbtrjjbWBRgU%2FUO4FMQlrf7TIlPryutLYT0%2Fimg.png)

<br/><br/>

### ☑️ 오류 제어(error control)
: **통신 중 데이터에 오류 또는 유실이 발생할 때 데이터의 신뢰성을 보장하기 위해 오류를 제어하는 방식**

- **데이터에 오류 또는 유실 발생을 인지하는 경우**
  - 수신부에서 잘못된 데이터를 받았다는 응답인 NAK(Negative Acknowledge) 메시지를 보낸 경우
  - 3 Duplicate ACK가 발생할 때
  - 수신부로부터 ACK 메시지를 받지 못해 타임아웃이 발생할 때

<br/>

#### ⏩ 오류 제어 방식

1. **정지-대기** <br/>
: **송신한 패킷에 대한 ACK 메시지를 일정 시간 동안 받지 못해 타임아웃이 발생하면, 해당 패킷을 다시 보내는 방식**
  - 흐름 제어에서 나왔던 방식으로, 데이터 유실을 간단히 처리할 수 있어서 오류 제어에서도 사용된다.
  - 이 방식은 송신부에서 데이터를 1개만 보내고 메시지를 기다려야 하기 때문에 ARQ 방식이 사용된다. 
    - ARQ(Automatic Repeat Request): 재전송 요청을 의미

<br/>

2. **Go-Back-N ARQ** <br/>
: **송신부에서 연속적으로 데이터를 보냈을 때, 누락된 데이터가 있으면 송신부에서 해당 데이터부터 재전송**하는 방식
   - ex) 송신부에서 패킷 0부터 패킷 2까지 보냈을 때 수신부에서 ACK 3 메시지를 보내면 송신부는 다음에 패킷 3부터 보낸다. 그리고 패킷 3부터 패킷 5까지 보냈을 때 ACK 4 메시지를 받으면 패킷 4와 패킷 5를 재전송한다.

<br/>

3. **Selective-Repeat ARQ** <br/>
: **송신부에서 연속적으로 데이터를 보냈을 때, 누락된 데이터가 있으면 수신부에서 해당 데이터만 재전송을 요청**하는 방식
   - ex) 수신부에서 패킷 0부터 패킷 2까지 잘 수신하면 패킷 3을 보내라는 의미의 ACK 3 메시지를 보낸다. <br/> 
➡︎ 그러고 나서 송신부에서 패킷 3부터 패킷 5까지 보냈을 때 패킷 4를 받지 못했다면 패킷 4를 보내라는 의미로 ACK 4 메시지를 보낸다. <br/>
➡︎ 이 요청을 받은 송신부는 패킷 4를 다시 보낸다. <br/>
➡︎ 이를 받은 수신부는 패킷 6을 요청한다. <br/>
특정 패킷만을 재전송한다는 점은 효율적으로 보이지만, 받은 패킷을 재정렬하는 로직이 추가로 필요하다.

<br/><br/>
<br/>

## ✅ UDP (User Datagram Protocol, 사용자 데이터그램 프로토콜)
: (TCP 같은) **전송 계층에 해당하는 네트워크 프로토콜**
- **송신부와 수신부 간 연결을 지원하지 않고 데이터그램 형태의 통신을 지원한다.** <br/>
➡︎ **TCP와 달리 3–way 핸드셰이킹 같은 과정 없이 패킷을 바로 송수신하게 된다.**
- 장점: 속도가 빠르다.
- 단점: 신뢰성이 낮다.

<br/>

#### ⏩ UDP의 특징
- **송신부와 수신부의 연결이 보장되지 않는 비연결형 서비스**다.
- 패킷이 서로 다른 회선으로 교환될 수 있는 데이터그램 패킷 교환 방식이다.
- 송신부에서 전달한 패킷 순서와 수신부에서 받은 패킷 순서가 다를 수 있다.
- 패킷의 수신 여부를 확인하지 않는다.
- 1:1 통신, 1:N 통신, N:N 통신 모두 가능하다.
- 데이터의 신뢰성이 낮다⬇️
- 데이터의 전송 속도가 빠르다⬆️

<br/>

#### ⏩ TCP와 UDP의 차이점

![](https://blog.kakaocdn.net/dn/yhP4R/btskhaWJdn7/qJypbu4t4jVbAhXXQlaPD1/img.png) <br/>
출처:[TCP와 UDP의 차이점](https://blog.kakaocdn.net/dn/yhP4R/btskhaWJdn7/qJypbu4t4jVbAhXXQlaPD1/img.png)

<br/><br/>
<br/>

## ✅ UDP의 오류 검출

- **오류 검출 방식**
  - **UDP는 최소한의 신뢰성을 보장하기 위해 체크섬(checksum) 오류를 검출한다.**
  - **체크섬(checksum)**: 전송된 데이터의 무결성을 확인하는 방법(중복 검사)
    - 체크섬 생성: 모든 데이터를 더한 후 오버플로우 되는 캐리를 다시 더하고, 1의 보수를 취해 만든다.

- **체크섬 생성 및 검증**
  - **송신부**
    - UDP 헤더, IP 헤더의 일부 정보(발신 IP 주소, 수신 IP 주소, 프로토콜 ID 등)와 데이터를 사용하여 체크섬 값을 생성한다. 
    - 생성한 체크섬 값을 UDP 헤더의 체크섬 영역에 넣어서 수신부에 보낸다.

  - **수신부**
    - 받은 데이터의 체크섬을 포함한 모든 값을 더해서 비트가 1이 나오는지 확인한다. <br/>
    - 모든 비트가 1이라면 송신부와 동일한 체크섬 값이 생성되었음을 의미한다. <br/>
➡︎ 데이터가 무결하게 전송되었음을 확인할 수 있다.

- **제한 사항**
  - **오류 검출의 한계** <br/>
    - 체크섬 방식은 데이터를 각각 비교하는 것이 아니라 값을 더해 확인하는 방식이기 때문에, 데이터 순서가 바뀌거나 특정 오류가 발생해도 체크섬 값이 동일할 수 있다. <br/>
➡︎ 오류를 100% 검출할 수는 없다.

  - **선택적 사용** <br/>
    - UDP에서 체크섬은 선택 사항이기 때문에 송신부가 체크섬 값을 0으로 설정하여 보내면 수신부는 체크섬을 계산하지 않는다.

<br/>

 - 👉 **UDP는 효율성을 중시하여 체크섬을 통해 기본적인 오류 검출을 제공**하지만, <br/> **신뢰성 있는 전송을 보장하지 않으며, 이는 상위 계층에서 처리해야 한다.**

<br/><br/>
